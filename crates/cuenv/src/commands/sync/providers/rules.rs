//! Rules file sync provider.
//!
//! Syncs configuration from .rules.cue files:
//! - Ignore files (.gitignore, .dockerignore, etc.) - per-directory
//! - EditorConfig (.editorconfig) - per-directory
//! - CODEOWNERS - aggregated to repo root

use async_trait::async_trait;
use cuenv_core::Result;
use cuenv_core::manifest::{DirectoryRules, Ignore, IgnoreValue};
use cuenv_editorconfig::{EditorConfigFile, EditorConfigSection as BuilderSection};
use cuenv_ignore::{IgnoreFile, IgnoreFiles};
use ignore::WalkBuilder;
use std::collections::HashMap;
use std::path::Path;

use crate::commands::CommandExecutor;
use crate::commands::sync::provider::{SyncMode, SyncOptions, SyncProvider, SyncResult};

/// Header added to all cuenv-generated files.
const CUENV_HEADER: &str = "Generated by cuenv - do not edit\nSource: .rules.cue";

/// Sync provider for .rules.cue files.
pub struct RulesSyncProvider;

#[async_trait]
impl SyncProvider for RulesSyncProvider {
    fn name(&self) -> &'static str {
        "rules"
    }

    fn description(&self) -> &'static str {
        "Sync configuration from .rules.cue files (ignore, editorconfig, codeowners)"
    }

    fn has_config(&self, _manifest: &cuenv_core::manifest::Base) -> bool {
        // This provider discovers .rules.cue files, not manifest config
        true
    }

    async fn sync_path(
        &self,
        path: &Path,
        _package: &str,
        options: &SyncOptions,
        executor: &CommandExecutor,
    ) -> Result<SyncResult> {
        let rules_file = path.join(".rules.cue");

        if !rules_file.exists() {
            return Ok(SyncResult::success(
                "No .rules.cue file found in this directory.",
            ));
        }

        let dry_run = options.mode == SyncMode::DryRun;
        let check = options.mode == SyncMode::Check;

        // Evaluate the .rules.cue file
        let config = evaluate_rules_file(&rules_file, executor)?;

        // Get repo root for determining if this is the root .rules.cue
        let repo_root = find_repo_root(path).unwrap_or_else(|| path.to_path_buf());
        let is_root = path == repo_root;

        let output = sync_directory_rules(path, &config, dry_run, check, is_root)?;

        Ok(SyncResult::success(output))
    }

    async fn sync_workspace(
        &self,
        _package: &str,
        options: &SyncOptions,
        executor: &CommandExecutor,
    ) -> Result<SyncResult> {
        let cwd = std::env::current_dir().map_err(|e| {
            cuenv_core::Error::configuration(format!("Failed to get current directory: {e}"))
        })?;

        let dry_run = options.mode == SyncMode::DryRun;
        let check = options.mode == SyncMode::Check;

        // Get repo root for determining which is the root .rules.cue
        let repo_root = find_repo_root(&cwd).unwrap_or_else(|| cwd.clone());

        // Discover all .rules.cue files manually (avoiding closure lifetime issues)
        let walker = WalkBuilder::new(&cwd)
            .follow_links(true)
            .standard_filters(true)
            .build();

        let mut discovered_files = Vec::new();
        for entry in walker.flatten() {
            let path = entry.path();
            if path.file_name() == Some(".rules.cue".as_ref()) {
                discovered_files.push(path.to_path_buf());
            }
        }

        if discovered_files.is_empty() {
            return Ok(SyncResult::success(
                "No .rules.cue files found in the repository.",
            ));
        }

        let mut outputs = Vec::new();
        let mut had_error = false;
        let mut all_owner_rules = HashMap::new();

        for rules_file in &discovered_files {
            let directory = match rules_file.parent() {
                Some(d) => d.to_path_buf(),
                None => continue,
            };

            // Evaluate the .rules.cue file
            let config = match evaluate_rules_file(rules_file, executor) {
                Ok(c) => c,
                Err(e) => {
                    tracing::warn!(
                        path = %rules_file.display(),
                        error = %e,
                        "Failed to evaluate .rules.cue - skipping"
                    );
                    outputs.push(format!("[{}] Error: {}", directory.display(), e));
                    had_error = true;
                    continue;
                }
            };

            let is_root = directory == repo_root;

            // Sync per-directory config (ignore, editorconfig)
            let result = sync_directory_rules(&directory, &config, dry_run, check, is_root);

            match result {
                Ok(output) if !output.is_empty() => {
                    let display = directory.strip_prefix(&cwd).unwrap_or(&directory).display();
                    outputs.push(format!("[{}]\n{}", display, output));
                }
                Ok(_) => {}
                Err(e) => {
                    outputs.push(format!("[{}] Error: {}", directory.display(), e));
                    had_error = true;
                }
            }

            // Collect owners for aggregation
            if let Some(ref owners) = config.owners {
                for (key, rule) in &owners.rules {
                    // Prefix with directory path for uniqueness
                    let prefixed_key = if directory == repo_root {
                        key.clone()
                    } else {
                        let prefix = directory
                            .strip_prefix(&repo_root)
                            .unwrap_or(&directory)
                            .to_string_lossy();
                        format!("{}:{}", prefix, key)
                    };
                    all_owner_rules.insert(prefixed_key, rule.clone());
                }
            }
        }

        // Generate aggregated CODEOWNERS at repo root
        if !all_owner_rules.is_empty() {
            let output = sync_codeowners(&repo_root, &all_owner_rules, dry_run, check);
            if !output.is_empty() {
                outputs.push(format!("[CODEOWNERS]\n{output}"));
            }
        }

        if outputs.is_empty() {
            Ok(SyncResult::success("No changes needed."))
        } else {
            Ok(SyncResult {
                output: outputs.join("\n\n"),
                had_error,
            })
        }
    }
}

/// Evaluate a .rules.cue file and return the parsed configuration.
fn evaluate_rules_file(file_path: &Path, executor: &CommandExecutor) -> Result<DirectoryRules> {
    let dir = file_path.parent().ok_or_else(|| {
        cuenv_core::Error::configuration(format!(
            "Invalid .rules.cue path: {}",
            file_path.display()
        ))
    })?;

    // Use the executor's module cache if available
    let module = executor.get_module(dir)?;

    // Get the instance for this directory
    let relative_path = crate::commands::relative_path_from_root(&module.root, dir);
    let instance = module.get(&relative_path).ok_or_else(|| {
        cuenv_core::Error::configuration(format!(
            "No CUE instance found for .rules.cue at: {}",
            dir.display()
        ))
    })?;

    // Deserialize as DirectoryRules
    instance.deserialize::<DirectoryRules>().map_err(|e| {
        cuenv_core::Error::configuration(format!(
            "Failed to parse .rules.cue at {}: {}",
            file_path.display(),
            e
        ))
    })
}

/// Sync per-directory rules (ignore files, editorconfig).
fn sync_directory_rules(
    directory: &Path,
    config: &DirectoryRules,
    dry_run: bool,
    check: bool,
    is_root: bool,
) -> Result<String> {
    let mut outputs = Vec::new();
    let effective_dry_run = dry_run || check;

    // Generate ignore files
    if let Some(ref ignore) = config.ignore {
        let output = sync_ignore_files(directory, ignore, effective_dry_run)?;
        if !output.is_empty() {
            outputs.push(output);
        }
    }

    // Generate editorconfig
    if let Some(ref editorconfig) = config.editorconfig {
        let output = sync_editorconfig(directory, editorconfig, effective_dry_run, is_root)?;
        if !output.is_empty() {
            outputs.push(output);
        }
    }

    // Check mode validation
    if check && !outputs.is_empty() {
        // In check mode, if we would have made changes, that's an error
        let changes: Vec<&str> = outputs
            .iter()
            .filter(|o| o.contains("Would"))
            .map(String::as_str)
            .collect();
        if !changes.is_empty() {
            return Err(cuenv_core::Error::configuration(format!(
                "Files are out of sync:\n{}",
                changes.join("\n")
            )));
        }
    }

    Ok(outputs.join("\n"))
}

/// Sync ignore files from Ignore configuration.
fn sync_ignore_files(directory: &Path, ignore: &Ignore, dry_run: bool) -> Result<String> {
    let files: Vec<IgnoreFile> = ignore
        .iter()
        .map(|(tool, value)| {
            let patterns = match value {
                IgnoreValue::Patterns(patterns) => patterns.clone(),
                IgnoreValue::Extended(entry) => entry.patterns.clone(),
            };
            let filename = match value {
                IgnoreValue::Patterns(_) => None,
                IgnoreValue::Extended(entry) => entry.filename.clone(),
            };
            IgnoreFile::new(tool)
                .patterns(patterns)
                .filename_opt(filename)
                .header(CUENV_HEADER)
        })
        .collect();

    if files.is_empty() {
        return Ok(String::new());
    }

    let result = IgnoreFiles::builder()
        .directory(directory)
        .require_git_repo(false) // Don't require git for .rules.cue files
        .dry_run(dry_run)
        .files(files)
        .generate()
        .map_err(|e| {
            cuenv_core::Error::configuration(format!("Failed to generate ignore files: {e}"))
        })?;

    let mut outputs = Vec::new();
    for file in &result.files {
        outputs.push(format!("{}: {}", file.filename, file.status));
    }

    Ok(outputs.join("\n"))
}

/// Sync editorconfig from EditorConfig configuration.
fn sync_editorconfig(
    directory: &Path,
    config: &cuenv_core::manifest::EditorConfig,
    dry_run: bool,
    is_root: bool,
) -> Result<String> {
    if config.sections.is_empty() {
        return Ok(String::new());
    }

    let mut builder = EditorConfigFile::builder()
        .directory(directory)
        .is_root(is_root)
        .header(CUENV_HEADER)
        .dry_run(dry_run);

    for (pattern, section) in &config.sections {
        let mut section_builder = BuilderSection::new();

        if let Some(ref style) = section.indent_style {
            section_builder = section_builder.indent_style(style);
        }
        if let Some(ref size) = section.indent_size {
            section_builder = match size {
                cuenv_core::manifest::EditorConfigValue::Int(n) => section_builder.indent_size(*n),
                cuenv_core::manifest::EditorConfigValue::String(s) if s == "tab" => {
                    section_builder.indent_size_tab()
                }
                cuenv_core::manifest::EditorConfigValue::String(_) => section_builder,
            };
        }
        if let Some(width) = section.tab_width {
            section_builder = section_builder.tab_width(width);
        }
        if let Some(ref eol) = section.end_of_line {
            section_builder = section_builder.end_of_line(eol);
        }
        if let Some(ref charset) = section.charset {
            section_builder = section_builder.charset(charset);
        }
        if let Some(trim) = section.trim_trailing_whitespace {
            section_builder = section_builder.trim_trailing_whitespace(trim);
        }
        if let Some(insert) = section.insert_final_newline {
            section_builder = section_builder.insert_final_newline(insert);
        }
        if let Some(ref length) = section.max_line_length {
            section_builder = match length {
                cuenv_core::manifest::EditorConfigValue::Int(n) => {
                    section_builder.max_line_length(*n)
                }
                cuenv_core::manifest::EditorConfigValue::String(s) if s == "off" => {
                    section_builder.max_line_length_off()
                }
                cuenv_core::manifest::EditorConfigValue::String(_) => section_builder,
            };
        }

        builder = builder.section(pattern, section_builder);
    }

    let result = builder.generate().map_err(|e| {
        cuenv_core::Error::configuration(format!("Failed to generate .editorconfig: {e}"))
    })?;

    Ok(format!(".editorconfig: {}", result.status))
}

/// Sync CODEOWNERS from aggregated owner rules.
fn sync_codeowners(
    _repo_root: &Path,
    rules: &HashMap<String, cuenv_core::owners::OwnerRule>,
    _dry_run: bool,
    _check: bool,
) -> String {
    // TODO: Implement CODEOWNERS generation using cuenv_codeowners crate
    // For now, just report that we would generate it
    if rules.is_empty() {
        return String::new();
    }

    format!(
        "Would aggregate {} ownership rules to CODEOWNERS",
        rules.len()
    )
}

/// Find the git repository root.
fn find_repo_root(start: &Path) -> Option<std::path::PathBuf> {
    let repo = gix::discover(start).ok()?;
    repo.workdir().map(|p| p.to_path_buf())
}
