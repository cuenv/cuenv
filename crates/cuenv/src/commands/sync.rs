//! Sync command implementation for generating files from CUE configuration.
//!
//! Supports generating:
//! - Ignore files (.gitignore, .dockerignore, etc.) from the `ignore` field
//! - CODEOWNERS file from the `owners` field
//! - Project files from CUE cube templates

use super::owners;
use cuengine::CueEvaluator;
use cuenv_core::Result;
use cuenv_core::manifest::{Base, Project};
use cuenv_ignore::{FileStatus, IgnoreFile, IgnoreFiles};
use std::path::{Path, PathBuf};
use tracing::instrument;

/// The header added to all cuenv-generated ignore files.
const CUENV_IGNORE_HEADER: &str = "Generated by cuenv - do not edit\nSource: env.cue";

/// Collect file paths from cube config where gitignore is true.
#[cfg(test)]
fn collect_cube_gitignore_patterns(manifest: &Project) -> Vec<String> {
    let Some(cube) = &manifest.cube else {
        return Vec::new();
    };

    let mut patterns: Vec<String> = cube
        .files
        .iter()
        .filter(|(_, file)| file.gitignore)
        .map(|(path, _)| path.clone())
        .collect();

    // Sort for deterministic output
    patterns.sort();
    patterns
}

/// Convert Base manifest ignore configuration to `cuenv_ignore::IgnoreFile` configs.
/// This version works with Base (no cube support).
fn convert_base_to_ignore_files(manifest: &Base) -> Vec<IgnoreFile> {
    let mut files = Vec::new();

    if let Some(ignore) = &manifest.ignore {
        for (tool, value) in ignore {
            let project_patterns: Vec<String> = value.patterns().to_vec();
            if !project_patterns.is_empty() {
                let mut patterns = vec!["# Project ignores".to_string()];
                patterns.extend(project_patterns);

                files.push(
                    IgnoreFile::new(tool)
                        .patterns(patterns)
                        .filename_opt(value.filename())
                        .header(CUENV_IGNORE_HEADER),
                );
            }
        }
    }

    files
}

/// Convert Project manifest ignore configuration to `cuenv_ignore::IgnoreFile` configs.
/// Also integrates cube-generated gitignore patterns.
#[cfg(test)]
fn convert_project_to_ignore_files(manifest: &Project) -> Vec<IgnoreFile> {
    let mut files = Vec::new();

    // Collect cube gitignore patterns
    let cube_patterns = collect_cube_gitignore_patterns(manifest);

    // Process project-level ignore configurations
    if let Some(ignore) = &manifest.ignore {
        for (tool, value) in ignore {
            let mut patterns: Vec<String> = Vec::new();

            // Add project-level patterns
            let project_patterns: Vec<String> = value.patterns().to_vec();
            if !project_patterns.is_empty() {
                patterns.push("# Project ignores".to_string());
                patterns.extend(project_patterns);
            }

            // For git, also add cube patterns
            if tool == "git" && !cube_patterns.is_empty() {
                if !patterns.is_empty() {
                    patterns.push(String::new()); // Empty line separator
                }
                patterns.push("# Cube-generated files".to_string());
                patterns.extend(cube_patterns.clone());
            }

            if !patterns.is_empty() {
                files.push(
                    IgnoreFile::new(tool)
                        .patterns(patterns)
                        .filename_opt(value.filename())
                        .header(CUENV_IGNORE_HEADER),
                );
            }
        }
    }

    // If there are cube patterns but no git ignore config, create one
    if !cube_patterns.is_empty() {
        let has_git_ignore = manifest
            .ignore
            .as_ref()
            .is_some_and(|i| i.contains_key("git"));

        if !has_git_ignore {
            let mut patterns = vec!["# Cube-generated files".to_string()];
            patterns.extend(cube_patterns);

            files.push(
                IgnoreFile::new("git")
                    .patterns(patterns)
                    .header(CUENV_IGNORE_HEADER),
            );
        }
    }

    files
}

/// Execute the sync ignore command.
///
/// Reads the CUE configuration and generates ignore files based on the `ignore` field.
/// Works with both schema.#Base and schema.#Project configurations.
#[instrument(name = "sync_ignore")]
pub async fn execute_sync_ignore(
    path: &str,
    package: &str,
    dry_run: bool,
    check: bool,
) -> Result<String> {
    tracing::info!("Starting sync ignore command");

    // Create CUE evaluator
    let evaluator = CueEvaluator::builder()
        .build()
        .map_err(super::convert_engine_error)?;

    // Convert path string to Path
    let dir_path = Path::new(path);

    // Evaluate the CUE package as Base (works with both #Base and #Project)
    tracing::debug!("Evaluating CUE package '{}' at path '{}'", package, path);
    let manifest: Base = evaluator
        .evaluate_typed(dir_path, package)
        .map_err(super::convert_engine_error)?;

    // Convert to ignore files (Base version - no cube support)
    let files = convert_base_to_ignore_files(&manifest);

    if files.is_empty() {
        tracing::info!("No ignore patterns configured");
        return Ok(
            "No ignore patterns configured. Add an `ignore` field to your env.cue.".to_string(),
        );
    }

    // Check if all files have empty patterns
    let all_empty = files.iter().all(|f| f.patterns_list().is_empty());
    if all_empty {
        return Ok("No ignore files to generate (all pattern lists are empty).".to_string());
    }

    // In check mode, use dry_run and verify files match
    let effective_dry_run = dry_run || check;

    // Generate ignore files using the cuenv-ignore crate
    let result = IgnoreFiles::builder()
        .directory(dir_path)
        .require_git_repo(true)
        .dry_run(effective_dry_run)
        .files(files)
        .generate()
        .map_err(|e| match e {
            cuenv_ignore::Error::NotInGitRepo => {
                cuenv_core::Error::configuration("cuenv sync must be run within a Git repository")
            }
            cuenv_ignore::Error::BareRepository => {
                cuenv_core::Error::configuration("Cannot sync in a bare Git repository")
            }
            cuenv_ignore::Error::OutsideGitRepo => cuenv_core::Error::configuration(
                "Target directory must be within the Git repository",
            ),
            cuenv_ignore::Error::InvalidToolName { name, reason } => {
                cuenv_core::Error::configuration(format!("Invalid tool name '{name}': {reason}"))
            }
            cuenv_ignore::Error::Io(io_err) => cuenv_core::Error::Io {
                source: io_err,
                path: Some(dir_path.to_path_buf().into_boxed_path()),
                operation: "sync ignore files".to_string(),
            },
        })?;

    // In check mode, verify all files are unchanged
    if check {
        let mut out_of_sync = Vec::new();
        for file in &result.files {
            match file.status {
                FileStatus::WouldCreate | FileStatus::WouldUpdate => {
                    out_of_sync.push(file.filename.clone());
                }
                FileStatus::Unchanged | FileStatus::Created | FileStatus::Updated => {}
            }
        }
        if !out_of_sync.is_empty() {
            return Err(cuenv_core::Error::configuration(format!(
                "Ignore files out of sync: {}. Run 'cuenv sync ignore' to update.",
                out_of_sync.join(", ")
            )));
        }
        return Ok("Ignore files are in sync.".to_string());
    }

    // Format output
    let mut output_lines = Vec::new();

    for file in &result.files {
        let status_str = match file.status {
            FileStatus::Created => format!(
                "Created {} ({} patterns)",
                file.filename, file.pattern_count
            ),
            FileStatus::Updated => format!(
                "Updated {} ({} patterns)",
                file.filename, file.pattern_count
            ),
            FileStatus::Unchanged => format!("Unchanged {}", file.filename),
            FileStatus::WouldCreate => format!(
                "Would create {} ({} patterns)",
                file.filename, file.pattern_count
            ),
            FileStatus::WouldUpdate => format!(
                "Would update {} ({} patterns)",
                file.filename, file.pattern_count
            ),
        };
        output_lines.push(status_str);
    }

    if output_lines.is_empty() {
        return Ok("No ignore files to generate (all pattern lists are empty).".to_string());
    }

    let output = output_lines.join("\n");
    tracing::info!("Sync ignore command completed successfully");
    Ok(output)
}

/// Execute the sync codeowners command.
///
/// Reads the CUE configuration and generates CODEOWNERS file based on the `owners` field.
/// When `allow_missing_config` is true, missing owners config will return a message instead of error.
#[instrument(name = "sync_codeowners")]
pub async fn execute_sync_codeowners(
    path: &str,
    package: &str,
    dry_run: bool,
    check: bool,
) -> Result<String> {
    execute_sync_codeowners_inner(path, package, dry_run, check, false).await
}

/// Execute the sync codeowners command with option to allow missing config.
pub async fn execute_sync_codeowners_optional(
    path: &str,
    package: &str,
    dry_run: bool,
    check: bool,
) -> Result<String> {
    execute_sync_codeowners_inner(path, package, dry_run, check, true).await
}

/// Inner implementation that handles the `allow_missing_config` flag.
async fn execute_sync_codeowners_inner(
    path: &str,
    package: &str,
    dry_run: bool,
    check: bool,
    allow_missing_config: bool,
) -> Result<String> {
    tracing::info!("Starting sync codeowners command");

    let result = if check {
        owners::execute_owners_check(path, package).await
    } else {
        owners::execute_owners_sync(path, package, dry_run).await
    };

    // When called from aggregate sync (allow_missing_config=true), treat missing config as no-op
    match result {
        Ok(output) => Ok(output),
        Err(cuenv_core::Error::Configuration { message, .. })
            if allow_missing_config && message.contains("No 'owners' configuration") =>
        {
            Ok("No owners configuration found. Add an 'owners' section to your env.cue to enable CODEOWNERS sync.".to_string())
        }
        Err(cuenv_core::Error::Configuration { message, .. })
            if allow_missing_config
                && message.contains("No code ownership rules defined") =>
        {
            Ok("No code ownership rules defined.".to_string())
        }
        Err(e) => Err(e),
    }
}

/// Execute the sync cubes command for a single project.
///
/// Syncs cube-generated files for the project at the specified path.
/// Use `execute_sync_cubes_workspace` for workspace-wide syncing.
#[instrument(name = "sync_cubes")]
pub async fn execute_sync_cubes(
    path: &str,
    package: &str,
    dry_run: bool,
    check: bool,
    diff: bool,
) -> Result<String> {
    let _ = diff; // TODO: implement diff mode
    tracing::info!("Starting sync cubes command");

    let dir_path = Path::new(path);
    execute_sync_cubes_local(dir_path, package, dry_run, check)
}

/// Sync cubes for the local project only
fn execute_sync_cubes_local(
    dir_path: &Path,
    package: &str,
    dry_run: bool,
    check: bool,
) -> Result<String> {
    // Auto-detect package name from env.cue if using default
    let effective_package = if package == "cuenv" {
        detect_package_name(dir_path)?
    } else {
        package.to_string()
    };

    let evaluator = CueEvaluator::builder()
        .build()
        .map_err(super::convert_engine_error)?;

    let manifest: Project = evaluator
        .evaluate_typed(dir_path, &effective_package)
        .map_err(super::convert_engine_error)?;

    let Some(cube_config) = &manifest.cube else {
        return Ok("No cube configuration found in this project.".to_string());
    };

    sync_cube_files(dir_path, &manifest.name, cube_config, dry_run, check)
}

/// Sync cubes for all projects in the workspace.
///
/// Discovers all projects from the CUE module root and syncs their cube files.
/// Called when --all flag is provided.
pub fn execute_sync_cubes_workspace(
    _package: &str,
    dry_run: bool,
    check: bool,
    _diff: bool,
) -> Result<String> {
    use cuenv_core::tasks::discovery::TaskDiscovery;

    // Find the CUE module root from current directory
    let cwd = std::env::current_dir().map_err(|e| {
        cuenv_core::Error::configuration(format!("Failed to get current directory: {e}"))
    })?;
    let module_root = find_cue_module_root(&cwd).ok_or_else(|| {
        cuenv_core::Error::configuration(
            "Not in a CUE module (no cue.mod found). Cannot use --all flag.",
        )
    })?;

    // Create evaluator for discovery
    let evaluator = CueEvaluator::builder()
        .build()
        .map_err(super::convert_engine_error)?;

    // Evaluation function for discovery
    let eval_fn: cuenv_core::tasks::discovery::EvalFn = Box::new(move |project_path: &Path| {
        let pkg = detect_package_name(project_path).map_err(|e| e.to_string())?;
        evaluator
            .evaluate_typed(project_path, &pkg)
            .map_err(|e| e.to_string())
    });

    let mut discovery = TaskDiscovery::new(module_root.clone()).with_eval_fn(eval_fn);
    discovery.discover().map_err(|e| {
        cuenv_core::Error::configuration(format!("Failed to discover projects: {e}"))
    })?;

    let mut output_lines = Vec::new();
    let mut total_files = 0;

    for project in discovery.projects() {
        let Some(cube_config) = &project.manifest.cube else {
            continue; // Skip projects without cube config
        };

        let project_output = sync_cube_files(
            &project.project_root,
            &project.manifest.name,
            cube_config,
            dry_run,
            check,
        )?;

        if !project_output.is_empty() {
            output_lines.push(format!("Project: {}", project.manifest.name));
            output_lines.push(project_output);
            total_files += cube_config.files.len();
        }
    }

    if output_lines.is_empty() {
        return Ok("No projects with cube configurations found.".to_string());
    }

    if dry_run {
        output_lines.insert(0, format!("Would generate {total_files} files:"));
    } else if check {
        output_lines.insert(0, format!("Checked {total_files} files:"));
    }

    Ok(output_lines.join("\n"))
}

/// Sync cube files for a single project
fn sync_cube_files(
    project_root: &Path,
    project_name: &str,
    cube_config: &cuenv_core::manifest::CubeConfig,
    dry_run: bool,
    check: bool,
) -> Result<String> {
    use cuenv_core::manifest::FileMode;

    let mut output_lines = Vec::new();

    for (file_path, file_def) in &cube_config.files {
        let output_path = project_root.join(file_path);

        match file_def.mode {
            FileMode::Managed => {
                if check {
                    // Check if file exists and matches
                    if output_path.exists() {
                        let existing = std::fs::read_to_string(&output_path).unwrap_or_default();
                        if existing == file_def.content {
                            output_lines.push(format!("  OK: {file_path}"));
                        } else {
                            output_lines.push(format!("  Out of sync: {file_path}"));
                        }
                    } else {
                        output_lines.push(format!("  Missing: {file_path}"));
                    }
                } else if dry_run {
                    if output_path.exists() {
                        output_lines.push(format!("  Would update: {file_path}"));
                    } else {
                        output_lines.push(format!("  Would create: {file_path}"));
                    }
                } else {
                    // Actually write the file
                    if let Some(parent) = output_path.parent() {
                        std::fs::create_dir_all(parent)?;
                    }
                    std::fs::write(&output_path, &file_def.content)?;
                    output_lines.push(format!("  Generated: {file_path}"));
                }
            }
            FileMode::Scaffold => {
                if output_path.exists() {
                    if !dry_run && !check {
                        tracing::debug!("Skipping {} (scaffold mode, file exists)", file_path);
                    }
                    output_lines.push(format!("  Skipped (exists): {file_path}"));
                } else if check {
                    output_lines.push(format!("  Missing scaffold: {file_path}"));
                } else if dry_run {
                    output_lines.push(format!("  Would scaffold: {file_path}"));
                } else {
                    // Actually write the file
                    if let Some(parent) = output_path.parent() {
                        std::fs::create_dir_all(parent)?;
                    }
                    std::fs::write(&output_path, &file_def.content)?;
                    output_lines.push(format!("  Scaffolded: {file_path}"));
                }
            }
        }
    }

    tracing::info!(
        project = project_name,
        files = cube_config.files.len(),
        "Cube sync complete"
    );

    Ok(output_lines.join("\n"))
}

/// Find the CUE module root by walking up directories looking for cue.mod
fn find_cue_module_root(start: &Path) -> Option<PathBuf> {
    let mut current = start.to_path_buf();
    loop {
        if current.join("cue.mod").exists() {
            return Some(current);
        }
        if !current.pop() {
            return None;
        }
    }
}

/// Detect the CUE package name from env.cue
fn detect_package_name(project_path: &Path) -> Result<String> {
    let env_cue = project_path.join("env.cue");
    if !env_cue.exists() {
        return Ok("cuenv".to_string());
    }

    let content = std::fs::read_to_string(&env_cue)?;
    for line in content.lines().take(10) {
        let trimmed = line.trim();
        if trimmed.starts_with("package ") {
            return Ok(trimmed
                .strip_prefix("package ")
                .unwrap_or("cuenv")
                .trim()
                .to_string());
        }
    }

    Ok("cuenv".to_string())
}

/// Sync ignore files for all Base configurations in the workspace.
///
/// Discovers all env.cue files with ignore configuration (both #Base and #Project)
/// from the CUE module root and syncs their ignore files.
/// Called when --all flag is provided.
///
/// This function uses `BaseDiscovery` which finds all env.cue files regardless of
/// whether they use schema.#Base or schema.#Project, enabling nested directories
/// with just ignore configuration to be included.
#[instrument(name = "sync_ignore_workspace", skip(_package))]
pub async fn execute_sync_ignore_workspace(
    _package: &str,
    dry_run: bool,
    check: bool,
) -> Result<String> {
    use cuenv_core::base::discovery::BaseDiscovery;

    // Find the CUE module root from current directory
    let cwd = std::env::current_dir().map_err(|e| {
        cuenv_core::Error::configuration(format!("Failed to get current directory: {e}"))
    })?;
    let module_root = find_cue_module_root(&cwd).ok_or_else(|| {
        cuenv_core::Error::configuration(
            "Not in a CUE module (no cue.mod found). Cannot use --all flag.",
        )
    })?;

    // Create evaluator for discovery
    let evaluator = CueEvaluator::builder()
        .build()
        .map_err(super::convert_engine_error)?;

    // Evaluation function for Base discovery
    let eval_fn: cuenv_core::base::discovery::BaseEvalFn = Box::new(move |project_path: &Path| {
        let pkg = detect_package_name(project_path).map_err(|e| e.to_string())?;
        evaluator
            .evaluate_typed(project_path, &pkg)
            .map_err(|e| e.to_string())
    });

    let mut discovery = BaseDiscovery::new(module_root).with_eval_fn(eval_fn);
    discovery.discover().map_err(|e| {
        cuenv_core::Error::configuration(format!("Failed to discover configs: {e}"))
    })?;

    let mut output_lines = Vec::new();
    let mut errors = Vec::new();

    for base in discovery.with_ignore() {
        let project_path = base.project_root.to_string_lossy();
        let pkg = detect_package_name(&base.project_root).unwrap_or_else(|_| "cuenv".to_string());

        match execute_sync_ignore(&project_path, &pkg, dry_run, check).await {
            Ok(output) => {
                if !output.contains("No ignore patterns")
                    && !output.contains("all pattern lists are empty")
                {
                    output_lines.push(format!("Config: {}", base.synthetic_name));
                    output_lines.push(output);
                    output_lines.push(String::new());
                }
            }
            Err(e) => {
                errors.push(format!("{}: {}", base.synthetic_name, e));
            }
        }
    }

    if !errors.is_empty() && output_lines.is_empty() {
        return Err(cuenv_core::Error::configuration(format!(
            "All configs failed:\n{}",
            errors.join("\n")
        )));
    }

    if output_lines.is_empty() {
        return Ok("No configs with ignore configuration found.".to_string());
    }

    if !errors.is_empty() {
        output_lines.push("Errors:".to_string());
        output_lines.extend(errors.into_iter().map(|e| format!("  {e}")));
    }

    Ok(output_lines.join("\n"))
}

/// Sync codeowners for all Base configurations in the workspace.
///
/// Discovers all env.cue files with owners configuration (both #Base and #Project)
/// from the CUE module root and aggregates their ownership rules into a single
/// CODEOWNERS file at the repository root.
///
/// This function uses `BaseDiscovery` which finds all env.cue files regardless of
/// whether they use schema.#Base or schema.#Project, enabling nested directories
/// with just owners configuration to be included.
#[allow(clippy::too_many_lines)]
#[instrument(name = "sync_codeowners_workspace", skip(_package))]
pub async fn execute_sync_codeowners_workspace(
    _package: &str,
    dry_run: bool,
    check: bool,
) -> Result<String> {
    use crate::providers::detect_codeowners_provider;
    use cuenv_codeowners::Rule;
    use cuenv_codeowners::provider::{ProjectOwners, SyncStatus};
    use cuenv_core::base::discovery::BaseDiscovery;

    // Find the CUE module root from current directory
    let cwd = std::env::current_dir().map_err(|e| {
        cuenv_core::Error::configuration(format!("Failed to get current directory: {e}"))
    })?;
    let module_root = find_cue_module_root(&cwd).ok_or_else(|| {
        cuenv_core::Error::configuration(
            "Not in a CUE module (no cue.mod found). Run from within a CUE module.",
        )
    })?;

    // Create evaluator for discovery
    let evaluator = CueEvaluator::builder()
        .build()
        .map_err(super::convert_engine_error)?;

    // Evaluation function for Base discovery
    let eval_fn: cuenv_core::base::discovery::BaseEvalFn = Box::new(move |project_path: &Path| {
        let pkg = detect_package_name(project_path).map_err(|e| e.to_string())?;
        evaluator
            .evaluate_typed(project_path, &pkg)
            .map_err(|e| e.to_string())
    });

    let mut discovery = BaseDiscovery::new(module_root.clone()).with_eval_fn(eval_fn);
    discovery.discover().map_err(|e| {
        cuenv_core::Error::configuration(format!("Failed to discover configs: {e}"))
    })?;

    // Collect all configs with owners configuration
    let mut project_owners_list = Vec::new();

    for base in discovery.with_owners() {
        let owners = base
            .manifest
            .owners
            .as_ref()
            .expect("filtered by with_owners");

        // Calculate relative path from module root to project
        let relative_path = base
            .project_root
            .strip_prefix(&module_root)
            .unwrap_or(&base.project_root)
            .to_path_buf();

        // Convert manifest rules to codeowners rules (sorted by order then key)
        let mut rule_entries: Vec<_> = owners.rules.iter().collect();
        rule_entries.sort_by(|a, b| {
            let order_a = a.1.order.unwrap_or(i32::MAX);
            let order_b = b.1.order.unwrap_or(i32::MAX);
            order_a.cmp(&order_b).then_with(|| a.0.cmp(b.0))
        });

        let rules: Vec<Rule> = rule_entries
            .iter()
            .map(|(_key, r)| {
                let mut rule = Rule::new(&r.pattern, r.owners.clone());
                if let Some(desc) = &r.description {
                    rule = rule.description(desc.to_owned());
                }
                if let Some(section) = &r.section {
                    rule = rule.section(section.to_owned());
                }
                rule
            })
            .collect();

        // Use synthetic name from directory path
        let proj_owners = ProjectOwners::new(relative_path, base.synthetic_name.clone(), rules);

        project_owners_list.push(proj_owners);
    }

    if project_owners_list.is_empty() {
        return Ok("No configs with owners configuration found.".to_string());
    }

    // Detect provider based on repo structure
    let provider = detect_codeowners_provider(&module_root);

    if check {
        // Check mode - verify CODEOWNERS is in sync
        let result = provider
            .check(&module_root, &project_owners_list)
            .map_err(|e| cuenv_core::Error::configuration(e.to_string()))?;

        if result.in_sync {
            Ok(format!(
                "CODEOWNERS file is in sync: {}",
                result.path.display()
            ))
        } else if result.actual.is_none() {
            Err(cuenv_core::Error::configuration(format!(
                "CODEOWNERS file not found at {}. Run 'cuenv sync codeowners' to generate it.",
                result.path.display()
            )))
        } else {
            Err(cuenv_core::Error::configuration(format!(
                "CODEOWNERS file is out of sync at {}. Run 'cuenv sync codeowners' to update it.",
                result.path.display()
            )))
        }
    } else {
        use std::fmt::Write;

        // Sync mode - write aggregated CODEOWNERS file
        let result = provider
            .sync(&module_root, &project_owners_list, dry_run)
            .map_err(|e| cuenv_core::Error::configuration(e.to_string()))?;

        let status_msg = match result.status {
            SyncStatus::Created => "Created",
            SyncStatus::Updated => "Updated",
            SyncStatus::Unchanged => "Unchanged",
            SyncStatus::WouldCreate => "Would create",
            SyncStatus::WouldUpdate => "Would update",
        };

        let mut output = format!("{} CODEOWNERS: {}\n", status_msg, result.path.display());

        // List configs included
        let _ = writeln!(
            output,
            "Aggregated {} config(s): {}",
            project_owners_list.len(),
            project_owners_list
                .iter()
                .map(|p| p.name.as_str())
                .collect::<Vec<_>>()
                .join(", ")
        );

        if dry_run {
            output.push_str("\n--- Content ---\n");
            output.push_str(&result.content);
        }

        Ok(output)
    }
}

/// Sync all (ignore + owners + cubes) for all configurations in the workspace.
///
/// Discovers configurations from the CUE module root and syncs all file types.
/// Called when --all flag is provided without a specific subcommand.
///
/// This function uses:
/// - `BaseDiscovery` for ignore and codeowners (finds all env.cue files, both #Base and #Project)
/// - `TaskDiscovery` for cubes (finds only #Project configs, since cube is Project-only)
#[instrument(name = "sync_all_workspace", skip(package))]
pub async fn execute_sync_all_workspace(
    package: &str,
    dry_run: bool,
    check: bool,
) -> Result<String> {
    let _ = package; // Reserved for future use
    use cuenv_core::base::discovery::{BaseDiscovery, DiscoveredBase};
    use cuenv_core::tasks::discovery::{DiscoveredProject, TaskDiscovery};

    // Find the CUE module root from current directory
    let cwd = std::env::current_dir().map_err(|e| {
        cuenv_core::Error::configuration(format!("Failed to get current directory: {e}"))
    })?;
    let module_root = find_cue_module_root(&cwd).ok_or_else(|| {
        cuenv_core::Error::configuration(
            "Not in a CUE module (no cue.mod found). Cannot use --all flag.",
        )
    })?;

    let mut outputs = Vec::new();
    let mut had_errors = false;

    // BaseDiscovery for ignore and codeowners (finds all env.cue, not just Projects)
    let base_evaluator = CueEvaluator::builder()
        .build()
        .map_err(super::convert_engine_error)?;

    let base_eval_fn: cuenv_core::base::discovery::BaseEvalFn =
        Box::new(move |project_path: &Path| {
            let pkg = detect_package_name(project_path).map_err(|e| e.to_string())?;
            base_evaluator
                .evaluate_typed(project_path, &pkg)
                .map_err(|e| e.to_string())
        });

    let mut base_discovery = BaseDiscovery::new(module_root.clone()).with_eval_fn(base_eval_fn);
    base_discovery.discover().map_err(|e| {
        cuenv_core::Error::configuration(format!("Failed to discover Base configs: {e}"))
    })?;

    let bases: Vec<DiscoveredBase> = base_discovery.bases().to_vec();

    // Run ignore sync using BaseDiscovery results
    match sync_ignore_with_bases(&bases, dry_run, check).await {
        Ok(output) if !output.contains("No configs with ignore") => {
            outputs.push("=== Ignore Files ===".to_string());
            outputs.push(output);
            outputs.push(String::new());
        }
        Ok(_) => {}
        Err(e) => {
            outputs.push(format!("=== Ignore Files ===\nError: {e}\n"));
            had_errors = true;
        }
    }

    // Run codeowners sync using BaseDiscovery results
    match sync_codeowners_with_bases(&bases, &module_root, dry_run, check).await {
        Ok(output) if !output.contains("No configs with owners") => {
            outputs.push("=== Codeowners ===".to_string());
            outputs.push(output);
            outputs.push(String::new());
        }
        Ok(_) => {}
        Err(e) => {
            outputs.push(format!("=== Codeowners ===\nError: {e}\n"));
            had_errors = true;
        }
    }

    // TaskDiscovery for cubes (Project-only feature)
    let project_evaluator = CueEvaluator::builder()
        .build()
        .map_err(super::convert_engine_error)?;

    let project_eval_fn: cuenv_core::tasks::discovery::EvalFn =
        Box::new(move |project_path: &Path| {
            let pkg = detect_package_name(project_path).map_err(|e| e.to_string())?;
            project_evaluator
                .evaluate_typed(project_path, &pkg)
                .map_err(|e| e.to_string())
        });

    let mut project_discovery =
        TaskDiscovery::new(module_root.clone()).with_eval_fn(project_eval_fn);
    // Note: discovery errors for cubes are not fatal - Base configs may still sync successfully
    if project_discovery.discover().is_ok() {
        let projects: Vec<DiscoveredProject> = project_discovery.projects().to_vec();

        // Run cubes sync using TaskDiscovery results
        match sync_cubes_with_projects(&projects, dry_run, check) {
            Ok(output) if !output.contains("No projects with cube") => {
                outputs.push("=== Cubes ===".to_string());
                outputs.push(output);
            }
            Ok(_) => {}
            Err(e) => {
                outputs.push(format!("=== Cubes ===\nError: {e}"));
                had_errors = true;
            }
        }
    }

    if outputs.is_empty() {
        return Ok("No configs with sync configuration found.".to_string());
    }

    let output = outputs.join("\n");

    if had_errors && !output.contains("Config:") && !output.contains("Project:") {
        return Err(cuenv_core::Error::configuration(output));
    }

    Ok(output)
}

/// Sync ignore files using pre-discovered Base configs (no re-discovery).
async fn sync_ignore_with_bases(
    bases: &[cuenv_core::base::discovery::DiscoveredBase],
    dry_run: bool,
    check: bool,
) -> Result<String> {
    let mut output_lines = Vec::new();
    let mut errors = Vec::new();

    for base in bases {
        // Skip configs without ignore
        if base.manifest.ignore.is_none() {
            continue;
        }

        let project_path = base.project_root.to_string_lossy();
        let pkg = detect_package_name(&base.project_root).unwrap_or_else(|_| "cuenv".to_string());

        match execute_sync_ignore(&project_path, &pkg, dry_run, check).await {
            Ok(output) => {
                if !output.contains("No ignore patterns")
                    && !output.contains("all pattern lists are empty")
                {
                    output_lines.push(format!("Config: {}", base.synthetic_name));
                    output_lines.push(output);
                    output_lines.push(String::new());
                }
            }
            Err(e) => {
                errors.push(format!("{}: {}", base.synthetic_name, e));
            }
        }
    }

    if !errors.is_empty() && output_lines.is_empty() {
        return Err(cuenv_core::Error::configuration(format!(
            "All configs failed:\n{}",
            errors.join("\n")
        )));
    }

    if output_lines.is_empty() {
        return Ok("No configs with ignore configuration found.".to_string());
    }

    if !errors.is_empty() {
        output_lines.push("Errors:".to_string());
        output_lines.extend(errors.into_iter().map(|e| format!("  {e}")));
    }

    Ok(output_lines.join("\n"))
}

/// Sync codeowners using pre-discovered Base configs (no re-discovery).
#[allow(clippy::unused_async)] // Async for API consistency with other sync functions
async fn sync_codeowners_with_bases(
    bases: &[cuenv_core::base::discovery::DiscoveredBase],
    module_root: &Path,
    dry_run: bool,
    check: bool,
) -> Result<String> {
    use crate::providers::detect_codeowners_provider;
    use cuenv_codeowners::Rule;
    use cuenv_codeowners::provider::{ProjectOwners, SyncStatus};

    // Collect all configs with owners configuration
    let mut project_owners_list = Vec::new();

    for base in bases {
        let Some(owners) = &base.manifest.owners else {
            continue;
        };

        // Calculate relative path from module root to project
        let relative_path = base
            .project_root
            .strip_prefix(module_root)
            .unwrap_or(&base.project_root)
            .to_path_buf();

        // Convert manifest rules to codeowners rules (sorted by order then key)
        let mut rule_entries: Vec<_> = owners.rules.iter().collect();
        rule_entries.sort_by(|a, b| {
            let order_a = a.1.order.unwrap_or(i32::MAX);
            let order_b = b.1.order.unwrap_or(i32::MAX);
            order_a.cmp(&order_b).then_with(|| a.0.cmp(b.0))
        });

        let rules: Vec<Rule> = rule_entries
            .iter()
            .map(|(_key, r)| {
                let mut rule = Rule::new(&r.pattern, r.owners.clone());
                if let Some(desc) = &r.description {
                    rule = rule.description(desc.to_owned());
                }
                if let Some(section) = &r.section {
                    rule = rule.section(section.to_owned());
                }
                rule
            })
            .collect();

        // Use synthetic name from directory path
        let proj_owners = ProjectOwners::new(relative_path, base.synthetic_name.clone(), rules);

        project_owners_list.push(proj_owners);
    }

    if project_owners_list.is_empty() {
        return Ok("No configs with owners configuration found.".to_string());
    }

    // Detect provider based on repo structure
    let provider = detect_codeowners_provider(module_root);

    if check {
        // Check mode - verify CODEOWNERS is in sync
        let result = provider
            .check(module_root, &project_owners_list)
            .map_err(|e| cuenv_core::Error::configuration(e.to_string()))?;

        if result.in_sync {
            Ok(format!(
                "CODEOWNERS file is in sync: {}",
                result.path.display()
            ))
        } else if result.actual.is_none() {
            Err(cuenv_core::Error::configuration(format!(
                "CODEOWNERS file not found at {}. Run 'cuenv sync codeowners' to generate it.",
                result.path.display()
            )))
        } else {
            Err(cuenv_core::Error::configuration(format!(
                "CODEOWNERS file is out of sync at {}. Run 'cuenv sync codeowners' to update it.",
                result.path.display()
            )))
        }
    } else {
        use std::fmt::Write;

        // Sync mode - write aggregated CODEOWNERS file
        let result = provider
            .sync(module_root, &project_owners_list, dry_run)
            .map_err(|e| cuenv_core::Error::configuration(e.to_string()))?;

        let status_msg = match result.status {
            SyncStatus::Created => "Created",
            SyncStatus::Updated => "Updated",
            SyncStatus::Unchanged => "Unchanged",
            SyncStatus::WouldCreate => "Would create",
            SyncStatus::WouldUpdate => "Would update",
        };

        let mut output = format!("{} CODEOWNERS: {}\n", status_msg, result.path.display());

        // List configs included
        let _ = writeln!(
            output,
            "Aggregated {} config(s): {}",
            project_owners_list.len(),
            project_owners_list
                .iter()
                .map(|p| p.name.as_str())
                .collect::<Vec<_>>()
                .join(", ")
        );

        if dry_run {
            output.push_str("\n--- Content ---\n");
            output.push_str(&result.content);
        }

        Ok(output)
    }
}

/// Sync cube files using pre-discovered projects (no re-discovery).
fn sync_cubes_with_projects(
    projects: &[cuenv_core::tasks::discovery::DiscoveredProject],
    dry_run: bool,
    check: bool,
) -> Result<String> {
    let mut output_lines = Vec::new();
    let mut total_files = 0;

    for project in projects {
        let Some(cube_config) = &project.manifest.cube else {
            continue; // Skip projects without cube config
        };

        let project_output = sync_cube_files(
            &project.project_root,
            &project.manifest.name,
            cube_config,
            dry_run,
            check,
        )?;

        if !project_output.is_empty() {
            output_lines.push(format!("Project: {}", project.manifest.name));
            output_lines.push(project_output);
            total_files += cube_config.files.len();
        }
    }

    if output_lines.is_empty() {
        return Ok("No projects with cube configurations found.".to_string());
    }

    if dry_run {
        output_lines.insert(0, format!("Would generate {total_files} files:"));
    } else if check {
        output_lines.insert(0, format!("Checked {total_files} files:"));
    }

    Ok(output_lines.join("\n"))
}

#[cfg(test)]
mod tests {
    use super::*;
    use cuenv_core::manifest::{CubeConfig, IgnoreEntry, IgnoreValue, ProjectFile};
    use std::collections::HashMap;

    #[test]
    fn test_convert_to_ignore_files_empty() {
        let manifest = Project::new("test");
        let files = convert_project_to_ignore_files(&manifest);
        assert!(files.is_empty());
    }

    #[test]
    fn test_convert_to_ignore_files_simple_patterns() {
        let mut manifest = Project::new("test");
        let mut ignore = HashMap::new();
        ignore.insert(
            "git".to_string(),
            IgnoreValue::Patterns(vec!["node_modules/".to_string(), ".env".to_string()]),
        );
        manifest.ignore = Some(ignore);

        let files = convert_project_to_ignore_files(&manifest);
        assert_eq!(files.len(), 1);
        assert_eq!(files[0].tool(), "git");
        // Patterns now include section comment
        assert_eq!(
            files[0].patterns_list(),
            &["# Project ignores", "node_modules/", ".env"]
        );
        assert_eq!(files[0].output_filename(), ".gitignore");
    }

    #[test]
    fn test_convert_to_ignore_files_extended_with_filename() {
        let mut manifest = Project::new("test");
        let mut ignore = HashMap::new();
        ignore.insert(
            "custom".to_string(),
            IgnoreValue::Extended(IgnoreEntry {
                patterns: vec!["*.tmp".to_string()],
                filename: Some(".myignore".to_string()),
            }),
        );
        manifest.ignore = Some(ignore);

        let files = convert_project_to_ignore_files(&manifest);
        assert_eq!(files.len(), 1);
        assert_eq!(files[0].tool(), "custom");
        // Patterns now include section comment
        assert_eq!(files[0].patterns_list(), &["# Project ignores", "*.tmp"]);
        assert_eq!(files[0].output_filename(), ".myignore");
    }

    #[test]
    fn test_convert_to_ignore_files_has_cuenv_header() {
        let mut manifest = Project::new("test");
        let mut ignore = HashMap::new();
        ignore.insert(
            "git".to_string(),
            IgnoreValue::Patterns(vec!["*.log".to_string()]),
        );
        manifest.ignore = Some(ignore);

        let files = convert_project_to_ignore_files(&manifest);
        let content = files[0].generate();

        assert!(content.contains("# Generated by cuenv"));
        assert!(content.contains("# Source: env.cue"));
    }

    // ============================================================================
    // Cube Gitignore Pattern Tests
    // ============================================================================

    #[test]
    fn test_collect_cube_gitignore_patterns_empty() {
        let manifest = Project::new("test");
        let patterns = collect_cube_gitignore_patterns(&manifest);
        assert!(patterns.is_empty());
    }

    #[test]
    fn test_collect_cube_gitignore_patterns_with_gitignore_true() {
        use cuenv_core::manifest::{FileMode, FormatConfig};

        let mut manifest = Project::new("test");
        let mut files = HashMap::new();
        files.insert(
            "dist/generated.js".to_string(),
            ProjectFile {
                content: "// generated".to_string(),
                language: "javascript".to_string(),
                mode: FileMode::default(),
                format: FormatConfig::default(),
                gitignore: true,
            },
        );
        files.insert(
            "src/main.ts".to_string(),
            ProjectFile {
                content: "// source".to_string(),
                language: "typescript".to_string(),
                mode: FileMode::default(),
                format: FormatConfig::default(),
                gitignore: false, // Should not be included
            },
        );
        manifest.cube = Some(CubeConfig {
            files,
            context: serde_json::Value::Null,
        });

        let patterns = collect_cube_gitignore_patterns(&manifest);
        assert_eq!(patterns.len(), 1);
        assert_eq!(patterns[0], "dist/generated.js");
    }

    #[test]
    fn test_collect_cube_gitignore_patterns_sorted() {
        use cuenv_core::manifest::{FileMode, FormatConfig};

        let mut manifest = Project::new("test");
        let mut files = HashMap::new();
        files.insert(
            "z-file.js".to_string(),
            ProjectFile {
                content: String::new(),
                language: "javascript".to_string(),
                mode: FileMode::default(),
                format: FormatConfig::default(),
                gitignore: true,
            },
        );
        files.insert(
            "a-file.js".to_string(),
            ProjectFile {
                content: String::new(),
                language: "javascript".to_string(),
                mode: FileMode::default(),
                format: FormatConfig::default(),
                gitignore: true,
            },
        );
        manifest.cube = Some(CubeConfig {
            files,
            context: serde_json::Value::Null,
        });

        let patterns = collect_cube_gitignore_patterns(&manifest);
        assert_eq!(patterns, vec!["a-file.js", "z-file.js"]);
    }

    #[test]
    fn test_convert_to_ignore_files_with_cube_patterns_only() {
        use cuenv_core::manifest::{FileMode, FormatConfig};

        let mut manifest = Project::new("test");
        let mut files = HashMap::new();
        files.insert(
            "dist/bundle.js".to_string(),
            ProjectFile {
                content: String::new(),
                language: "javascript".to_string(),
                mode: FileMode::default(),
                format: FormatConfig::default(),
                gitignore: true,
            },
        );
        manifest.cube = Some(CubeConfig {
            files,
            context: serde_json::Value::Null,
        });

        let ignore_files = convert_project_to_ignore_files(&manifest);
        assert_eq!(ignore_files.len(), 1);
        assert_eq!(ignore_files[0].tool(), "git");
        assert_eq!(
            ignore_files[0].patterns_list(),
            &["# Cube-generated files", "dist/bundle.js"]
        );
    }

    #[test]
    fn test_convert_to_ignore_files_with_both_project_and_cube_patterns() {
        use cuenv_core::manifest::{FileMode, FormatConfig};

        let mut manifest = Project::new("test");

        // Add project-level git ignores
        let mut ignore = HashMap::new();
        ignore.insert(
            "git".to_string(),
            IgnoreValue::Patterns(vec!["node_modules/".to_string()]),
        );
        manifest.ignore = Some(ignore);

        // Add cube files with gitignore: true
        let mut files = HashMap::new();
        files.insert(
            "dist/bundle.js".to_string(),
            ProjectFile {
                content: String::new(),
                language: "javascript".to_string(),
                mode: FileMode::default(),
                format: FormatConfig::default(),
                gitignore: true,
            },
        );
        manifest.cube = Some(CubeConfig {
            files,
            context: serde_json::Value::Null,
        });

        let ignore_files = convert_project_to_ignore_files(&manifest);
        assert_eq!(ignore_files.len(), 1);
        assert_eq!(ignore_files[0].tool(), "git");

        let patterns = ignore_files[0].patterns_list();
        assert!(patterns.contains(&"# Project ignores".to_string()));
        assert!(patterns.contains(&"node_modules/".to_string()));
        assert!(patterns.contains(&"# Cube-generated files".to_string()));
        assert!(patterns.contains(&"dist/bundle.js".to_string()));
    }

    #[test]
    fn test_cube_patterns_not_added_to_non_git_ignores() {
        use cuenv_core::manifest::{FileMode, FormatConfig};

        let mut manifest = Project::new("test");

        // Add docker ignores (not git)
        let mut ignore = HashMap::new();
        ignore.insert(
            "docker".to_string(),
            IgnoreValue::Patterns(vec!["node_modules/".to_string()]),
        );
        manifest.ignore = Some(ignore);

        // Add cube files with gitignore: true
        let mut files = HashMap::new();
        files.insert(
            "dist/bundle.js".to_string(),
            ProjectFile {
                content: String::new(),
                language: "javascript".to_string(),
                mode: FileMode::default(),
                format: FormatConfig::default(),
                gitignore: true,
            },
        );
        manifest.cube = Some(CubeConfig {
            files,
            context: serde_json::Value::Null,
        });

        let ignore_files = convert_project_to_ignore_files(&manifest);
        // Should have 2 files: docker (without cube patterns) and git (with cube patterns only)
        assert_eq!(ignore_files.len(), 2);

        let docker_file = ignore_files.iter().find(|f| f.tool() == "docker").unwrap();
        let git_file = ignore_files.iter().find(|f| f.tool() == "git").unwrap();

        // Docker should not have cube patterns
        assert!(
            !docker_file
                .patterns_list()
                .contains(&"dist/bundle.js".to_string())
        );

        // Git should have cube patterns
        assert!(
            git_file
                .patterns_list()
                .contains(&"dist/bundle.js".to_string())
        );
    }
}
