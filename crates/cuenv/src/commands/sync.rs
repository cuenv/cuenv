//! Sync command implementation for generating files from CUE configuration.
//!
//! Currently supports generating ignore files (.gitignore, .dockerignore, etc.)
//! from the `ignore` field in the CUE configuration.

use cuengine::{CueEvaluator, Cuenv};
use cuenv_core::Result;
use std::path::Path;
use tracing::instrument;

/// Standard mapping of tool names to their ignore file names.
/// Custom keys not in this map will generate `.<key>ignore` files.
fn get_ignore_filename(tool: &str) -> String {
    match tool {
        "git" => ".gitignore".to_string(),
        "docker" => ".dockerignore".to_string(),
        "npm" => ".npmignore".to_string(),
        "prettier" => ".prettierignore".to_string(),
        "eslint" => ".eslintignore".to_string(),
        "stylelint" => ".stylelintignore".to_string(),
        "vercel" => ".vercelignore".to_string(),
        "nowignore" => ".nowignore".to_string(),
        // Custom tools get .<tool>ignore
        custom => format!(".{custom}ignore"),
    }
}

/// Generate the content for an ignore file with a header.
fn generate_ignore_content(patterns: &[String]) -> String {
    let mut lines = vec![
        "# Generated by cuenv - do not edit".to_string(),
        "# Source: env.cue".to_string(),
        String::new(),
    ];
    lines.extend(patterns.iter().cloned());
    lines.join("\n")
}

/// Execute the sync command.
///
/// Reads the CUE configuration and generates ignore files based on the `ignore` field.
#[instrument(name = "sync")]
pub async fn execute_sync(path: &str, package: &str, dry_run: bool) -> Result<String> {
    tracing::info!("Starting sync command");

    // Create CUE evaluator
    let evaluator = CueEvaluator::builder().build()?;

    // Convert path string to Path
    let dir_path = Path::new(path);

    // Evaluate the CUE package
    tracing::debug!("Evaluating CUE package '{}' at path '{}'", package, path);
    let manifest: Cuenv = evaluator.evaluate_typed(dir_path, package)?;

    // Get ignore configuration
    let ignore = match &manifest.ignore {
        Some(ignore) if !ignore.is_empty() => ignore,
        _ => {
            tracing::info!("No ignore patterns configured");
            return Ok("No ignore patterns configured. Add an `ignore` field to your env.cue.".to_string());
        }
    };

    let mut output_lines = Vec::new();

    // Sort keys for deterministic output
    let mut tools: Vec<&String> = ignore.keys().collect();
    tools.sort();

    for tool in tools {
        let patterns = &ignore[tool];
        if patterns.is_empty() {
            continue;
        }

        let filename = get_ignore_filename(tool);
        let filepath = dir_path.join(&filename);
        let content = generate_ignore_content(patterns);

        if dry_run {
            output_lines.push(format!("Would generate {filename}:"));
            output_lines.push("---".to_string());
            output_lines.push(content);
            output_lines.push("---".to_string());
            output_lines.push(String::new());
        } else {
            // Write the file
            std::fs::write(&filepath, &content).map_err(|e| cuenv_core::Error::Io {
                source: e,
                path: Some(filepath.clone().into_boxed_path()),
                operation: "write ignore file".to_string(),
            })?;

            output_lines.push(format!("Generated {filename} ({} patterns)", patterns.len()));
        }
    }

    if output_lines.is_empty() {
        return Ok("No ignore files to generate (all pattern lists are empty).".to_string());
    }

    let output = output_lines.join("\n");
    tracing::info!("Sync command completed successfully");
    Ok(output)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_ignore_filename_standard_tools() {
        assert_eq!(get_ignore_filename("git"), ".gitignore");
        assert_eq!(get_ignore_filename("docker"), ".dockerignore");
        assert_eq!(get_ignore_filename("npm"), ".npmignore");
        assert_eq!(get_ignore_filename("prettier"), ".prettierignore");
        assert_eq!(get_ignore_filename("eslint"), ".eslintignore");
        assert_eq!(get_ignore_filename("stylelint"), ".stylelintignore");
        assert_eq!(get_ignore_filename("vercel"), ".vercelignore");
    }

    #[test]
    fn test_get_ignore_filename_custom_tools() {
        assert_eq!(get_ignore_filename("custom"), ".customignore");
        assert_eq!(get_ignore_filename("myapp"), ".myappignore");
    }

    #[test]
    fn test_generate_ignore_content() {
        let patterns = vec![
            "node_modules/".to_string(),
            ".env".to_string(),
            "*.log".to_string(),
        ];
        let content = generate_ignore_content(&patterns);

        assert!(content.starts_with("# Generated by cuenv - do not edit"));
        assert!(content.contains("# Source: env.cue"));
        assert!(content.contains("node_modules/"));
        assert!(content.contains(".env"));
        assert!(content.contains("*.log"));
    }

    #[test]
    fn test_generate_ignore_content_empty() {
        let patterns: Vec<String> = vec![];
        let content = generate_ignore_content(&patterns);

        assert!(content.starts_with("# Generated by cuenv - do not edit"));
        assert!(content.contains("# Source: env.cue"));
        // Should just have the header lines
        let lines: Vec<&str> = content.lines().collect();
        assert_eq!(lines.len(), 2); // Header + source line (empty line is trimmed)
    }
}
