//! 1Password WASM SDK `SharedCore` wrapper
//!
//! This module provides a thread-safe wrapper around the 1Password WASM SDK,
//! following the same pattern as the official Go SDK.

#[cfg(feature = "onepassword")]
use crate::SecretError;

#[cfg(feature = "onepassword")]
use extism::{CurrentPlugin, Function, Manifest, Plugin, UserData, Val, ValType, Wasm};

#[cfg(feature = "onepassword")]
use std::sync::{LazyLock, Mutex};

/// Global `SharedCore` instance, lazily initialized
#[cfg(feature = "onepassword")]
static SHARED_CORE: LazyLock<Mutex<Option<SharedCore>>> = LazyLock::new(|| Mutex::new(None));

/// Create host functions required by the 1Password WASM SDK.
///
/// These match the imports expected by the 1Password core WASM module:
/// - `random_fill_imported` (op-extism-core): Generates cryptographically secure random bytes
/// - `unix_time_milliseconds_imported` (op-now): Returns current Unix time in milliseconds
/// - `unix_time_milliseconds_imported` (zxcvbn): Same as above, for password strength checking
/// - `utc_offset_seconds` (op-time): Returns local timezone offset in seconds
#[cfg(feature = "onepassword")]
fn create_host_functions() -> Vec<Function> {
    use rand::RngCore;
    use std::time::{SystemTime, UNIX_EPOCH};

    // random_fill_imported: Generate random bytes and return pointer to them in WASM memory
    // Input: i32 (length of bytes to generate)
    // Output: i64 (pointer to the generated bytes in WASM memory)
    let random_fill = Function::new(
        "random_fill_imported",
        [ValType::I32],
        [ValType::I64],
        UserData::new(()),
        |plugin: &mut CurrentPlugin, inputs: &[Val], outputs: &mut [Val], _: UserData<()>| {
            let length = inputs[0].unwrap_i32() as usize;

            // Generate cryptographically secure random bytes
            let mut bytes = vec![0u8; length];
            rand::rng().fill_bytes(&mut bytes);

            // Write bytes to WASM memory using memory_new (equivalent to Go's WriteBytes)
            let handle = plugin
                .memory_new(&bytes)
                .map_err(|e| extism::Error::msg(format!("Failed to write bytes: {e}")))?;

            outputs[0] = Val::I64(handle.offset() as i64);
            Ok(())
        },
    )
    .with_namespace("op-extism-core");

    // unix_time_milliseconds_imported for "op-now" namespace
    // Input: none
    // Output: i64 (current Unix time in milliseconds)
    let time_op_now = Function::new(
        "unix_time_milliseconds_imported",
        [],
        [ValType::I64],
        UserData::new(()),
        |_plugin: &mut CurrentPlugin, _inputs: &[Val], outputs: &mut [Val], _: UserData<()>| {
            let now = SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap_or_default()
                .as_millis() as i64;
            outputs[0] = Val::I64(now);
            Ok(())
        },
    )
    .with_namespace("op-now");

    // unix_time_milliseconds_imported for "zxcvbn" namespace (password strength)
    let time_zxcvbn = Function::new(
        "unix_time_milliseconds_imported",
        [],
        [ValType::I64],
        UserData::new(()),
        |_plugin: &mut CurrentPlugin, _inputs: &[Val], outputs: &mut [Val], _: UserData<()>| {
            let now = SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .unwrap_or_default()
                .as_millis() as i64;
            outputs[0] = Val::I64(now);
            Ok(())
        },
    )
    .with_namespace("zxcvbn");

    // utc_offset_seconds: Return local timezone offset from UTC in seconds
    // Input: none
    // Output: i64 (offset in seconds)
    let utc_offset = Function::new(
        "utc_offset_seconds",
        [],
        [ValType::I64],
        UserData::new(()),
        |_plugin: &mut CurrentPlugin, _inputs: &[Val], outputs: &mut [Val], _: UserData<()>| {
            // Get local timezone offset using chrono
            let offset_seconds = chrono::Local::now().offset().local_minus_utc() as i64;
            outputs[0] = Val::I64(offset_seconds);
            Ok(())
        },
    )
    .with_namespace("op-time");

    vec![random_fill, time_op_now, time_zxcvbn, utc_offset]
}

/// `SharedCore` wraps the 1Password WASM plugin for thread-safe access.
///
/// The WASM runtime is single-threaded, so we use a mutex to serialize access.
/// This follows the same pattern as the official 1Password Go SDK.
#[cfg(feature = "onepassword")]
pub struct SharedCore {
    plugin: Plugin,
}

#[cfg(feature = "onepassword")]
impl SharedCore {
    /// Get or initialize the shared core.
    ///
    /// On first call, loads the WASM from disk and initializes the plugin.
    /// Subsequent calls return the cached instance.
    pub fn get_or_init() -> Result<&'static Mutex<Option<SharedCore>>, SecretError> {
        let mut guard = SHARED_CORE
            .lock()
            .map_err(|_| SecretError::ResolutionFailed {
                name: "onepassword".to_string(),
                message: "Failed to acquire shared core lock".to_string(),
            })?;

        if guard.is_none() {
            let wasm_bytes = crate::wasm::load_onepassword_wasm()?;

            let manifest = Manifest::new([Wasm::data(wasm_bytes)]).with_allowed_hosts(
                ["*.1password.com".to_string(), "*.b5dev.com".to_string()].into_iter(),
            );

            let host_functions = create_host_functions();
            let plugin = Plugin::new(&manifest, host_functions, true).map_err(|e| {
                SecretError::ResolutionFailed {
                    name: "onepassword".to_string(),
                    message: format!("Failed to initialize WASM plugin: {e}"),
                }
            })?;

            *guard = Some(SharedCore { plugin });
        }

        // Drop guard before returning static reference
        drop(guard);
        Ok(&SHARED_CORE)
    }

    /// Initialize a new 1Password client.
    ///
    /// Returns a client ID that can be used for subsequent `invoke` calls.
    pub fn init_client(&mut self, token: &str) -> Result<String, SecretError> {
        let config = serde_json::json!({
            "serviceAccountToken": token,
            "programmingLanguage": "Rust",
            "sdkVersion": env!("CARGO_PKG_VERSION"),
            "integrationName": "cuenv",
            "integrationVersion": env!("CARGO_PKG_VERSION"),
        });

        let result = self
            .plugin
            .call::<_, String>("init_client", config.to_string())
            .map_err(|e| SecretError::ResolutionFailed {
                name: "onepassword".to_string(),
                message: format!("Failed to initialize client: {e}"),
            })?;

        // Parse the response to check for errors
        let response: serde_json::Value =
            serde_json::from_str(&result).map_err(|e| SecretError::ResolutionFailed {
                name: "onepassword".to_string(),
                message: format!("Failed to parse init_client response: {e}"),
            })?;

        // Check for error in response
        if let Some(error) = response.get("error") {
            return Err(SecretError::ResolutionFailed {
                name: "onepassword".to_string(),
                message: format!("1Password client init failed: {error}"),
            });
        }

        // Extract client ID
        response["clientId"]
            .as_str()
            .map(ToString::to_string)
            .ok_or_else(|| SecretError::ResolutionFailed {
                name: "onepassword".to_string(),
                message: "No clientId in response".to_string(),
            })
    }

    /// Invoke a method on the 1Password client.
    ///
    /// The method name and parameters depend on the specific operation.
    /// For resolving secrets, use method "Secrets.Resolve" with the secret reference.
    pub fn invoke(
        &mut self,
        client_id: &str,
        method: &str,
        params: &str,
    ) -> Result<String, SecretError> {
        let request = serde_json::json!({
            "clientId": client_id,
            "invocation": {
                "methodName": method,
                "parameters": params
            }
        });

        let result = self
            .plugin
            .call::<_, String>("invoke", request.to_string())
            .map_err(|e| SecretError::ResolutionFailed {
                name: "onepassword".to_string(),
                message: format!("Invoke failed: {e}"),
            })?;

        // Parse response to check for errors
        let response: serde_json::Value =
            serde_json::from_str(&result).map_err(|e| SecretError::ResolutionFailed {
                name: "onepassword".to_string(),
                message: format!("Failed to parse invoke response: {e}"),
            })?;

        if let Some(error) = response.get("error") {
            return Err(SecretError::ResolutionFailed {
                name: "onepassword".to_string(),
                message: format!("1Password invoke failed: {error}"),
            });
        }

        Ok(result)
    }

    /// Release a 1Password client.
    ///
    /// This should be called when the client is no longer needed.
    pub fn release_client(&mut self, client_id: &str) {
        let _ = self.plugin.call::<_, String>("release_client", client_id);
    }
}

#[cfg(test)]
mod tests {
    #[cfg(feature = "onepassword")]
    use super::*;

    #[test]
    #[cfg(feature = "onepassword")]
    fn test_shared_core_lazy_init() {
        // This test just verifies the lazy static compiles
        // Actual WASM loading requires the file to exist
        let _ = &SHARED_CORE;
    }
}
