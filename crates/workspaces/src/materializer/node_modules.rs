//! Materializer for Node.js dependencies (`node_modules`).

use super::Materializer;
use crate::core::types::{LockfileEntry, PackageManager, Workspace};
use crate::error::{Error, Result};
use std::path::{Path, PathBuf};

#[cfg(unix)]
use std::os::unix::fs::symlink;
#[cfg(windows)]
use std::os::windows::fs::symlink_dir as symlink;

/// Materializer for Node.js projects.
pub struct NodeModulesMaterializer;

impl Materializer for NodeModulesMaterializer {
    fn materialize(
        &self,
        workspace: &Workspace,
        _entries: &[LockfileEntry],
        target_dir: &Path,
    ) -> Result<()> {
        if !matches!(
            workspace.manager,
            PackageManager::Npm
                | PackageManager::Bun
                | PackageManager::Pnpm
                | PackageManager::YarnClassic
                | PackageManager::YarnModern
        ) {
            return Ok(());
        }

        // Strategy:
        // 1. Symlink the entire node_modules from workspace root if it exists.
        //    This allows leveraging the existing installed dependencies.
        // 2. (Future) Link individual packages from global cache (pnpm store, etc.)
        //    for granular, hermetic population.

        let workspace_nm = workspace.root.join("node_modules");
        let target_nm = target_dir.join("node_modules");

        if workspace_nm.exists() {
            if !target_nm.exists() {
                symlink(&workspace_nm, &target_nm).map_err(|e| Error::Io {
                    source: e,
                    path: Some(target_nm.clone()),
                    operation: "symlink node_modules".to_string(),
                })?;
            }
        } else {
            // Warn or log that dependencies might be missing?
            // For now, we assume if node_modules is missing, the user might run install
            // or we are in a state where it's not needed yet.
        }

        Ok(())
    }
}

impl NodeModulesMaterializer {
    /// Detects the global cache directory for the package manager.
    ///
    /// This can be used in the future to populate dependencies directly from cache.
    pub fn detect_cache_dir(manager: PackageManager) -> Option<PathBuf> {
        let home = std::env::var_os("HOME")
            .or_else(|| std::env::var_os("USERPROFILE"))
            .map(PathBuf::from)?;

        match manager {
            PackageManager::Npm => Some(home.join(".npm")),
            PackageManager::Pnpm => {
                // pnpm store path can vary (v3, etc), checking common default
                Some(home.join(".local/share/pnpm/store/v3"))
            }
            PackageManager::Bun => Some(home.join(".bun/install/cache")),
            PackageManager::YarnClassic => Some(home.join(".yarn/cache")),
            PackageManager::YarnModern => Some(home.join(".yarn/berry/cache")),
            PackageManager::Deno => Some(home.join(".cache/deno")),
            PackageManager::Cargo => None,
        }
    }
}

#[cfg(test)]
#[allow(unsafe_code)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    fn make_workspace(root: &Path, manager: PackageManager) -> Workspace {
        Workspace::new(root.to_path_buf(), manager)
    }

    // ==========================================================================
    // NodeModulesMaterializer::materialize tests
    // ==========================================================================

    #[test]
    fn test_node_modules_materializer_skips_cargo() {
        let temp_dir = TempDir::new().unwrap();
        let workspace = make_workspace(temp_dir.path(), PackageManager::Cargo);
        let target_dir = temp_dir.path().join("hermetic");
        fs::create_dir_all(&target_dir).unwrap();

        let materializer = NodeModulesMaterializer;
        let result = materializer.materialize(&workspace, &[], &target_dir);

        assert!(result.is_ok());
        // No symlink should be created for Cargo projects
        assert!(!target_dir.join("node_modules").exists());
    }

    #[test]
    fn test_node_modules_materializer_handles_npm() {
        let temp_dir = TempDir::new().unwrap();
        let workspace = make_workspace(temp_dir.path(), PackageManager::Npm);
        let target_dir = temp_dir.path().join("hermetic");
        fs::create_dir_all(&target_dir).unwrap();

        // Create source node_modules
        let workspace_nm = temp_dir.path().join("node_modules");
        fs::create_dir_all(&workspace_nm).unwrap();
        fs::write(workspace_nm.join("marker"), "npm").unwrap();

        let materializer = NodeModulesMaterializer;
        let result = materializer.materialize(&workspace, &[], &target_dir);

        assert!(result.is_ok());
        // Symlink should be created
        assert!(target_dir.join("node_modules").exists());
    }

    #[test]
    fn test_node_modules_materializer_handles_bun() {
        let temp_dir = TempDir::new().unwrap();
        let workspace = make_workspace(temp_dir.path(), PackageManager::Bun);
        let target_dir = temp_dir.path().join("hermetic");
        fs::create_dir_all(&target_dir).unwrap();

        // Create source node_modules
        let workspace_nm = temp_dir.path().join("node_modules");
        fs::create_dir_all(&workspace_nm).unwrap();

        let materializer = NodeModulesMaterializer;
        let result = materializer.materialize(&workspace, &[], &target_dir);

        assert!(result.is_ok());
        assert!(target_dir.join("node_modules").exists());
    }

    #[test]
    fn test_node_modules_materializer_handles_pnpm() {
        let temp_dir = TempDir::new().unwrap();
        let workspace = make_workspace(temp_dir.path(), PackageManager::Pnpm);
        let target_dir = temp_dir.path().join("hermetic");
        fs::create_dir_all(&target_dir).unwrap();

        // Create source node_modules
        let workspace_nm = temp_dir.path().join("node_modules");
        fs::create_dir_all(&workspace_nm).unwrap();

        let materializer = NodeModulesMaterializer;
        let result = materializer.materialize(&workspace, &[], &target_dir);

        assert!(result.is_ok());
        assert!(target_dir.join("node_modules").exists());
    }

    #[test]
    fn test_node_modules_materializer_handles_yarn_classic() {
        let temp_dir = TempDir::new().unwrap();
        let workspace = make_workspace(temp_dir.path(), PackageManager::YarnClassic);
        let target_dir = temp_dir.path().join("hermetic");
        fs::create_dir_all(&target_dir).unwrap();

        // Create source node_modules
        let workspace_nm = temp_dir.path().join("node_modules");
        fs::create_dir_all(&workspace_nm).unwrap();

        let materializer = NodeModulesMaterializer;
        let result = materializer.materialize(&workspace, &[], &target_dir);

        assert!(result.is_ok());
        assert!(target_dir.join("node_modules").exists());
    }

    #[test]
    fn test_node_modules_materializer_handles_yarn_modern() {
        let temp_dir = TempDir::new().unwrap();
        let workspace = make_workspace(temp_dir.path(), PackageManager::YarnModern);
        let target_dir = temp_dir.path().join("hermetic");
        fs::create_dir_all(&target_dir).unwrap();

        // Create source node_modules
        let workspace_nm = temp_dir.path().join("node_modules");
        fs::create_dir_all(&workspace_nm).unwrap();

        let materializer = NodeModulesMaterializer;
        let result = materializer.materialize(&workspace, &[], &target_dir);

        assert!(result.is_ok());
        assert!(target_dir.join("node_modules").exists());
    }

    #[test]
    fn test_node_modules_materializer_no_source_node_modules() {
        let temp_dir = TempDir::new().unwrap();
        let workspace = make_workspace(temp_dir.path(), PackageManager::Npm);
        let target_dir = temp_dir.path().join("hermetic");
        fs::create_dir_all(&target_dir).unwrap();

        // Don't create source node_modules

        let materializer = NodeModulesMaterializer;
        let result = materializer.materialize(&workspace, &[], &target_dir);

        // Should succeed but not create symlink
        assert!(result.is_ok());
        assert!(!target_dir.join("node_modules").exists());
    }

    #[test]
    fn test_node_modules_materializer_skips_if_target_exists() {
        let temp_dir = TempDir::new().unwrap();
        let workspace = make_workspace(temp_dir.path(), PackageManager::Npm);
        let target_dir = temp_dir.path().join("hermetic");
        fs::create_dir_all(&target_dir).unwrap();

        // Create source node_modules
        let workspace_nm = temp_dir.path().join("node_modules");
        fs::create_dir_all(&workspace_nm).unwrap();
        fs::write(workspace_nm.join("marker"), "source").unwrap();

        // Pre-create target node_modules (simulating previous symlink)
        let target_nm = target_dir.join("node_modules");
        fs::create_dir_all(&target_nm).unwrap();
        fs::write(target_nm.join("existing"), "keep").unwrap();

        let materializer = NodeModulesMaterializer;
        let result = materializer.materialize(&workspace, &[], &target_dir);

        assert!(result.is_ok());
        // Existing directory should be preserved (code skips if target exists)
        assert!(target_nm.join("existing").exists());
    }

    // ==========================================================================
    // NodeModulesMaterializer::detect_cache_dir tests
    // ==========================================================================

    #[test]
    fn test_detect_cache_dir_npm() {
        // Set HOME for test
        // SAFETY: Test runs in isolation, setting env var is acceptable
        unsafe { std::env::set_var("HOME", "/home/test") };
        let cache = NodeModulesMaterializer::detect_cache_dir(PackageManager::Npm);
        assert!(cache.is_some());
        assert!(cache.unwrap().ends_with(".npm"));
    }

    #[test]
    fn test_detect_cache_dir_pnpm() {
        // SAFETY: Test runs in isolation, setting env var is acceptable
        unsafe { std::env::set_var("HOME", "/home/test") };
        let cache = NodeModulesMaterializer::detect_cache_dir(PackageManager::Pnpm);
        assert!(cache.is_some());
        let cache_path = cache.unwrap();
        assert!(cache_path.to_string_lossy().contains("pnpm"));
    }

    #[test]
    fn test_detect_cache_dir_bun() {
        // SAFETY: Test runs in isolation, setting env var is acceptable
        unsafe { std::env::set_var("HOME", "/home/test") };
        let cache = NodeModulesMaterializer::detect_cache_dir(PackageManager::Bun);
        assert!(cache.is_some());
        let cache_path = cache.unwrap();
        assert!(cache_path.to_string_lossy().contains("bun"));
    }

    #[test]
    fn test_detect_cache_dir_yarn_classic() {
        // SAFETY: Test runs in isolation, setting env var is acceptable
        unsafe { std::env::set_var("HOME", "/home/test") };
        let cache = NodeModulesMaterializer::detect_cache_dir(PackageManager::YarnClassic);
        assert!(cache.is_some());
        let cache_path = cache.unwrap();
        assert!(cache_path.to_string_lossy().contains("yarn"));
    }

    #[test]
    fn test_detect_cache_dir_yarn_modern() {
        // SAFETY: Test runs in isolation, setting env var is acceptable
        unsafe { std::env::set_var("HOME", "/home/test") };
        let cache = NodeModulesMaterializer::detect_cache_dir(PackageManager::YarnModern);
        assert!(cache.is_some());
        let cache_path = cache.unwrap();
        assert!(cache_path.to_string_lossy().contains("berry"));
    }

    #[test]
    fn test_detect_cache_dir_deno() {
        // SAFETY: Test runs in isolation, setting env var is acceptable
        unsafe { std::env::set_var("HOME", "/home/test") };
        let cache = NodeModulesMaterializer::detect_cache_dir(PackageManager::Deno);
        assert!(cache.is_some());
        let cache_path = cache.unwrap();
        assert!(cache_path.to_string_lossy().contains("deno"));
    }

    #[test]
    fn test_detect_cache_dir_cargo_returns_none() {
        // SAFETY: Test runs in isolation, setting env var is acceptable
        unsafe { std::env::set_var("HOME", "/home/test") };
        let cache = NodeModulesMaterializer::detect_cache_dir(PackageManager::Cargo);
        assert!(cache.is_none());
    }
}
