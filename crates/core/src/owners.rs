//! Code ownership configuration types
//!
//! Based on schema/owners.cue

use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use std::fmt;
use std::path::Path;

/// Platform for CODEOWNERS file generation
#[derive(Debug, Clone, Copy, Serialize, Deserialize, JsonSchema, PartialEq, Default)]
#[serde(rename_all = "lowercase")]
pub enum Platform {
    #[default]
    Github,
    Gitlab,
    Bitbucket,
}

impl Platform {
    /// Get the default path for CODEOWNERS file on this platform
    pub fn default_path(&self) -> &'static str {
        match self {
            Platform::Github => ".github/CODEOWNERS",
            Platform::Gitlab => "CODEOWNERS",
            Platform::Bitbucket => "CODEOWNERS",
        }
    }
}

impl fmt::Display for Platform {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Platform::Github => write!(f, "github"),
            Platform::Gitlab => write!(f, "gitlab"),
            Platform::Bitbucket => write!(f, "bitbucket"),
        }
    }
}

/// Output configuration for CODEOWNERS file generation
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, PartialEq, Default)]
pub struct OwnersOutput {
    /// Platform to generate CODEOWNERS for
    pub platform: Option<Platform>,

    /// Custom path for CODEOWNERS file (overrides platform default)
    pub path: Option<String>,

    /// Header comment to include at the top of the generated file
    pub header: Option<String>,
}

impl OwnersOutput {
    /// Get the output path for the CODEOWNERS file
    pub fn output_path(&self) -> &str {
        if let Some(ref path) = self.path {
            path
        } else {
            self.platform.unwrap_or_default().default_path()
        }
    }
}

/// A single code ownership rule
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, PartialEq)]
pub struct OwnerRule {
    /// File pattern (glob syntax) - same as CODEOWNERS format
    pub pattern: String,

    /// Owners for this pattern
    pub owners: Vec<String>,

    /// Optional description for this rule (added as comment above the rule)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,

    /// Section name for grouping rules in the output file
    #[serde(skip_serializing_if = "Option::is_none")]
    pub section: Option<String>,
}

/// Code ownership configuration for a project
#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, PartialEq, Default)]
#[serde(rename_all = "camelCase")]
pub struct Owners {
    /// Output configuration for CODEOWNERS file generation
    #[serde(skip_serializing_if = "Option::is_none")]
    pub output: Option<OwnersOutput>,

    /// Global default owners applied to all patterns without explicit owners
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_owners: Option<Vec<String>>,

    /// Code ownership rules - maps patterns to owners
    #[serde(default)]
    pub rules: Vec<OwnerRule>,
}

impl Owners {
    /// Generate the CODEOWNERS file content
    pub fn generate(&self) -> String {
        let mut output = String::new();

        // Add header if provided
        if let Some(ref header) = self.output.as_ref().and_then(|o| o.header.as_ref()) {
            for line in header.lines() {
                output.push_str("# ");
                output.push_str(line);
                output.push('\n');
            }
            output.push('\n');
        } else {
            // Default header
            output.push_str("# CODEOWNERS file - Generated by cuenv\n");
            output.push_str("# Do not edit manually. Configure in env.cue and run `cuenv owners sync`\n");
            output.push('\n');
        }

        // Add default owners if any
        if let Some(ref default_owners) = self.default_owners {
            if !default_owners.is_empty() {
                output.push_str("# Default owners for all files\n");
                output.push_str("* ");
                output.push_str(&default_owners.join(" "));
                output.push('\n');
                output.push('\n');
            }
        }

        // Group rules by section
        let mut current_section: Option<&str> = None;

        for rule in &self.rules {
            // Handle section headers
            if rule.section.as_deref() != current_section {
                if current_section.is_some() {
                    output.push('\n');
                }
                if let Some(ref section) = rule.section {
                    output.push_str("# ");
                    output.push_str(section);
                    output.push('\n');
                }
                current_section = rule.section.as_deref();
            }

            // Add description as comment if provided
            if let Some(ref description) = rule.description {
                output.push_str("# ");
                output.push_str(description);
                output.push('\n');
            }

            // Add the rule
            output.push_str(&rule.pattern);
            output.push(' ');
            output.push_str(&rule.owners.join(" "));
            output.push('\n');
        }

        output
    }

    /// Get the output path for the CODEOWNERS file
    pub fn output_path(&self) -> &str {
        self.output
            .as_ref()
            .map(|o| o.output_path())
            .unwrap_or_else(|| Platform::default().default_path())
    }

    /// Detect platform from repository structure
    pub fn detect_platform(repo_root: &Path) -> Platform {
        if repo_root.join(".github").is_dir() {
            Platform::Github
        } else if repo_root.join(".gitlab-ci.yml").exists() {
            Platform::Gitlab
        } else if repo_root.join("bitbucket-pipelines.yml").exists() {
            Platform::Bitbucket
        } else {
            Platform::Github // Default to GitHub
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_platform_default_paths() {
        assert_eq!(Platform::Github.default_path(), ".github/CODEOWNERS");
        assert_eq!(Platform::Gitlab.default_path(), "CODEOWNERS");
        assert_eq!(Platform::Bitbucket.default_path(), "CODEOWNERS");
    }

    #[test]
    fn test_owners_output_path() {
        // Default (no output config)
        let owners = Owners::default();
        assert_eq!(owners.output_path(), ".github/CODEOWNERS");

        // With platform specified
        let owners = Owners {
            output: Some(OwnersOutput {
                platform: Some(Platform::Gitlab),
                path: None,
                header: None,
            }),
            ..Default::default()
        };
        assert_eq!(owners.output_path(), "CODEOWNERS");

        // With custom path
        let owners = Owners {
            output: Some(OwnersOutput {
                platform: Some(Platform::Github),
                path: Some("docs/CODEOWNERS".to_string()),
                header: None,
            }),
            ..Default::default()
        };
        assert_eq!(owners.output_path(), "docs/CODEOWNERS");
    }

    #[test]
    fn test_generate_simple() {
        let owners = Owners {
            rules: vec![
                OwnerRule {
                    pattern: "*.rs".to_string(),
                    owners: vec!["@rust-team".to_string()],
                    description: None,
                    section: None,
                },
                OwnerRule {
                    pattern: "/docs/**".to_string(),
                    owners: vec!["@docs-team".to_string(), "@tech-writers".to_string()],
                    description: None,
                    section: None,
                },
            ],
            ..Default::default()
        };

        let content = owners.generate();
        assert!(content.contains("*.rs @rust-team"));
        assert!(content.contains("/docs/** @docs-team @tech-writers"));
    }

    #[test]
    fn test_generate_with_sections() {
        let owners = Owners {
            rules: vec![
                OwnerRule {
                    pattern: "*.rs".to_string(),
                    owners: vec!["@backend".to_string()],
                    description: Some("Rust source files".to_string()),
                    section: Some("Backend".to_string()),
                },
                OwnerRule {
                    pattern: "*.ts".to_string(),
                    owners: vec!["@frontend".to_string()],
                    description: None,
                    section: Some("Frontend".to_string()),
                },
            ],
            ..Default::default()
        };

        let content = owners.generate();
        assert!(content.contains("# Backend"));
        assert!(content.contains("# Rust source files"));
        assert!(content.contains("# Frontend"));
    }

    #[test]
    fn test_generate_with_default_owners() {
        let owners = Owners {
            default_owners: Some(vec!["@core-team".to_string()]),
            rules: vec![OwnerRule {
                pattern: "/security/**".to_string(),
                owners: vec!["@security-team".to_string()],
                description: None,
                section: None,
            }],
            ..Default::default()
        };

        let content = owners.generate();
        assert!(content.contains("* @core-team"));
        assert!(content.contains("/security/** @security-team"));
    }

    #[test]
    fn test_generate_with_custom_header() {
        let owners = Owners {
            output: Some(OwnersOutput {
                platform: None,
                path: None,
                header: Some("Custom Header\nLine 2".to_string()),
            }),
            rules: vec![],
            ..Default::default()
        };

        let content = owners.generate();
        assert!(content.contains("# Custom Header"));
        assert!(content.contains("# Line 2"));
    }
}
