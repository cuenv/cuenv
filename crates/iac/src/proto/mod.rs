//! Generated protobuf types for Terraform provider protocol v6.
//!
//! This module contains the gRPC client stubs and message types generated
//! from the tfplugin6.proto definition.

// Include the generated code
// Note: The actual file is generated by build.rs during compilation.
// During development, we use a placeholder file that provides type definitions.
#[allow(clippy::all)]
#[allow(missing_docs)]
#[allow(clippy::pedantic)]
mod tfplugin6;

pub use tfplugin6::*;

use serde::{Deserialize, Serialize};

use crate::error::{Error, Result};

/// Extension methods for `DynamicValue`.
impl DynamicValue {
    /// Creates a new `DynamicValue` from a JSON serializable value.
    ///
    /// Uses MessagePack encoding as the primary format (preferred by Terraform).
    ///
    /// # Errors
    ///
    /// Returns an error if serialization fails.
    pub fn from_value<T: Serialize>(value: &T) -> Result<Self> {
        let msgpack = rmp_serde::to_vec(value)?;
        Ok(Self {
            msgpack,
            json: Vec::new(),
        })
    }

    /// Creates a new `DynamicValue` from a JSON serializable value using JSON encoding.
    ///
    /// Use this when MessagePack encoding is not supported.
    ///
    /// # Errors
    ///
    /// Returns an error if serialization fails.
    pub fn from_value_json<T: Serialize>(value: &T) -> Result<Self> {
        let json = serde_json::to_vec(value)?;
        Ok(Self {
            msgpack: Vec::new(),
            json,
        })
    }

    /// Deserializes the `DynamicValue` to a typed value.
    ///
    /// Attempts MessagePack first, then falls back to JSON.
    ///
    /// # Errors
    ///
    /// Returns an error if deserialization fails.
    pub fn to_value<T: for<'de> Deserialize<'de>>(&self) -> Result<T> {
        if !self.msgpack.is_empty() {
            Ok(rmp_serde::from_slice(&self.msgpack)?)
        } else if !self.json.is_empty() {
            Ok(serde_json::from_slice(&self.json)?)
        } else {
            Err(Error::MsgPack("DynamicValue is empty".to_string()))
        }
    }

    /// Returns the value as a `serde_json::Value`.
    ///
    /// # Errors
    ///
    /// Returns an error if deserialization fails.
    pub fn to_json_value(&self) -> Result<serde_json::Value> {
        self.to_value()
    }

    /// Checks if the dynamic value is empty.
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.msgpack.is_empty() && self.json.is_empty()
    }

    /// Creates a null `DynamicValue`.
    #[must_use]
    pub fn null() -> Self {
        Self::from_value(&serde_json::Value::Null).unwrap_or(Self {
            msgpack: Vec::new(),
            json: b"null".to_vec(),
        })
    }
}

/// Extension methods for `Diagnostic`.
impl Diagnostic {
    /// Creates an error diagnostic.
    #[must_use]
    pub fn error(summary: impl Into<String>, detail: impl Into<String>) -> Self {
        Self {
            severity: diagnostic::Severity::Error as i32,
            summary: summary.into(),
            detail: detail.into(),
            attribute: None,
        }
    }

    /// Creates a warning diagnostic.
    #[must_use]
    pub fn warning(summary: impl Into<String>, detail: impl Into<String>) -> Self {
        Self {
            severity: diagnostic::Severity::Warning as i32,
            summary: summary.into(),
            detail: detail.into(),
            attribute: None,
        }
    }

    /// Returns true if this is an error diagnostic.
    #[must_use]
    pub fn is_error(&self) -> bool {
        self.severity == diagnostic::Severity::Error as i32
    }

    /// Returns true if this is a warning diagnostic.
    #[must_use]
    pub fn is_warning(&self) -> bool {
        self.severity == diagnostic::Severity::Warning as i32
    }
}

/// Checks a list of diagnostics for errors.
///
/// # Errors
///
/// Returns an error if any diagnostic is an error.
pub fn check_diagnostics(diagnostics: &[Diagnostic]) -> Result<()> {
    let errors: Vec<_> = diagnostics.iter().filter(|d| d.is_error()).collect();

    if errors.is_empty() {
        Ok(())
    } else {
        let messages: Vec<_> = errors
            .iter()
            .map(|d| format!("{}: {}", d.summary, d.detail))
            .collect();

        Err(Error::ProviderDiagnostics(messages.join("; ")))
    }
}

/// Terraform type system representation.
///
/// This maps to the cty type system used by Terraform.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum TerraformType {
    /// Primitive type ("string", "number", "bool")
    Primitive(String),
    /// Complex type (["list", "string"], ["map", "number"], etc.)
    Complex(Vec<serde_json::Value>),
}

impl TerraformType {
    /// Creates a string type.
    #[must_use]
    pub fn string() -> Self {
        Self::Primitive("string".to_string())
    }

    /// Creates a number type.
    #[must_use]
    pub fn number() -> Self {
        Self::Primitive("number".to_string())
    }

    /// Creates a bool type.
    #[must_use]
    pub fn bool() -> Self {
        Self::Primitive("bool".to_string())
    }

    /// Creates a dynamic type (any).
    #[must_use]
    pub fn dynamic() -> Self {
        Self::Primitive("dynamic".to_string())
    }

    /// Creates a list type with the given element type.
    #[must_use]
    pub fn list(element_type: Self) -> Self {
        Self::Complex(vec![
            serde_json::Value::String("list".to_string()),
            serde_json::to_value(element_type).unwrap_or(serde_json::Value::Null),
        ])
    }

    /// Creates a map type with the given value type.
    #[must_use]
    pub fn map(value_type: Self) -> Self {
        Self::Complex(vec![
            serde_json::Value::String("map".to_string()),
            serde_json::to_value(value_type).unwrap_or(serde_json::Value::Null),
        ])
    }

    /// Creates a set type with the given element type.
    #[must_use]
    pub fn set(element_type: Self) -> Self {
        Self::Complex(vec![
            serde_json::Value::String("set".to_string()),
            serde_json::to_value(element_type).unwrap_or(serde_json::Value::Null),
        ])
    }

    /// Creates an object type with the given attribute types.
    #[must_use]
    pub fn object(attributes: std::collections::HashMap<String, Self>) -> Self {
        Self::Complex(vec![
            serde_json::Value::String("object".to_string()),
            serde_json::to_value(attributes).unwrap_or(serde_json::Value::Null),
        ])
    }

    /// Parses a type from its JSON encoding.
    ///
    /// # Errors
    ///
    /// Returns an error if parsing fails.
    pub fn from_bytes(bytes: &[u8]) -> Result<Self> {
        Ok(serde_json::from_slice(bytes)?)
    }

    /// Encodes the type to JSON bytes.
    ///
    /// # Errors
    ///
    /// Returns an error if encoding fails.
    pub fn to_bytes(&self) -> Result<Vec<u8>> {
        Ok(serde_json::to_vec(self)?)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_dynamic_value_roundtrip() {
        let original = serde_json::json!({
            "name": "test",
            "count": 42,
            "enabled": true
        });

        let dv = DynamicValue::from_value(&original).unwrap();
        let decoded: serde_json::Value = dv.to_value().unwrap();

        assert_eq!(original, decoded);
    }

    #[test]
    fn test_terraform_type_encoding() {
        let t = TerraformType::list(TerraformType::string());
        let bytes = t.to_bytes().unwrap();
        let decoded = TerraformType::from_bytes(&bytes).unwrap();

        match decoded {
            TerraformType::Complex(v) => {
                assert_eq!(v[0], serde_json::Value::String("list".to_string()));
            }
            _ => panic!("Expected complex type"),
        }
    }
}
