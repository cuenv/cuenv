// This file is generated by tonic-build during compilation.
// It will be overwritten by build.rs.
//
// For development, this placeholder allows IDE tooling to work.
// Run `cargo build` to generate the actual bindings.

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(missing_docs)]

// Placeholder types for IDE support before build
// These will be replaced by tonic_build::compile_protos

/// Provider service client placeholder
pub mod provider_client {
    use tonic::codegen::*;

    #[derive(Debug, Clone)]
    pub struct ProviderClient<T> {
        inner: T,
    }

    impl<T> ProviderClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            Self { inner }
        }
    }
}

// Placeholder message types
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DynamicValue {
    #[prost(bytes = "vec", tag = "1")]
    pub msgpack: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub json: ::prost::alloc::vec::Vec<u8>,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Diagnostic {
    #[prost(int32, tag = "1")]
    pub severity: i32,
    #[prost(string, tag = "2")]
    pub summary: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub detail: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub attribute: ::core::option::Option<AttributePath>,
}

pub mod diagnostic {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Severity {
        Invalid = 0,
        Error = 1,
        Warning = 2,
    }
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AttributePath {
    #[prost(message, repeated, tag = "1")]
    pub steps: ::prost::alloc::vec::Vec<attribute_path::Step>,
}

pub mod attribute_path {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Step {
        #[prost(oneof = "step::Selector", tags = "1, 2, 3")]
        pub selector: ::core::option::Option<step::Selector>,
    }

    pub mod step {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Selector {
            #[prost(string, tag = "1")]
            AttributeName(::prost::alloc::string::String),
            #[prost(int64, tag = "2")]
            ElementKeyInt(i64),
            #[prost(string, tag = "3")]
            ElementKeyString(::prost::alloc::string::String),
        }
    }
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    #[prost(int64, tag = "1")]
    pub version: i64,
    #[prost(message, optional, tag = "2")]
    pub block: ::core::option::Option<schema::Block>,
}

pub mod schema {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Block {
        #[prost(int64, tag = "1")]
        pub version: i64,
        #[prost(message, repeated, tag = "2")]
        pub attributes: ::prost::alloc::vec::Vec<Attribute>,
        #[prost(message, repeated, tag = "3")]
        pub block_types: ::prost::alloc::vec::Vec<NestedBlock>,
        #[prost(string, tag = "4")]
        pub description: ::prost::alloc::string::String,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Attribute {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(bytes = "vec", tag = "2")]
        pub r#type: ::prost::alloc::vec::Vec<u8>,
        #[prost(string, tag = "4")]
        pub description: ::prost::alloc::string::String,
        #[prost(bool, tag = "5")]
        pub required: bool,
        #[prost(bool, tag = "6")]
        pub optional: bool,
        #[prost(bool, tag = "7")]
        pub computed: bool,
        #[prost(bool, tag = "8")]
        pub sensitive: bool,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NestedBlock {
        #[prost(string, tag = "1")]
        pub type_name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub block: ::core::option::Option<Block>,
        #[prost(enumeration = "nested_block::NestingMode", tag = "3")]
        pub nesting: i32,
        #[prost(int64, tag = "4")]
        pub min_items: i64,
        #[prost(int64, tag = "5")]
        pub max_items: i64,
    }

    pub mod nested_block {
        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
        #[repr(i32)]
        pub enum NestingMode {
            Invalid = 0,
            Single = 1,
            List = 2,
            Set = 3,
            Map = 4,
            Group = 5,
        }
    }
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RawState {
    #[prost(bytes = "vec", tag = "1")]
    pub json: ::prost::alloc::vec::Vec<u8>,
    #[prost(map = "string, string", tag = "2")]
    pub flatmap: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}

// Request/Response message placeholders
pub mod get_provider_schema {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Request {}

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(message, optional, tag = "1")]
        pub provider: ::core::option::Option<super::Schema>,
        #[prost(map = "string, message", tag = "2")]
        pub resource_schemas:
            ::std::collections::HashMap<::prost::alloc::string::String, super::Schema>,
        #[prost(map = "string, message", tag = "3")]
        pub data_source_schemas:
            ::std::collections::HashMap<::prost::alloc::string::String, super::Schema>,
        #[prost(message, repeated, tag = "4")]
        pub diagnostics: ::prost::alloc::vec::Vec<super::Diagnostic>,
    }
}

pub mod configure_provider {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Request {
        #[prost(string, tag = "1")]
        pub terraform_version: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub config: ::core::option::Option<super::DynamicValue>,
        #[prost(message, optional, tag = "3")]
        pub client_capabilities: ::core::option::Option<super::ClientCapabilities>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(message, repeated, tag = "1")]
        pub diagnostics: ::prost::alloc::vec::Vec<super::Diagnostic>,
    }
}

pub mod validate_provider_config {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Request {
        #[prost(message, optional, tag = "1")]
        pub config: ::core::option::Option<super::DynamicValue>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(message, repeated, tag = "2")]
        pub diagnostics: ::prost::alloc::vec::Vec<super::Diagnostic>,
    }
}

pub mod validate_resource_config {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Request {
        #[prost(string, tag = "1")]
        pub type_name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub config: ::core::option::Option<super::DynamicValue>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(message, repeated, tag = "1")]
        pub diagnostics: ::prost::alloc::vec::Vec<super::Diagnostic>,
    }
}

pub mod read_resource {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Request {
        #[prost(string, tag = "1")]
        pub type_name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub current_state: ::core::option::Option<super::DynamicValue>,
        #[prost(bytes = "vec", tag = "3")]
        pub private: ::prost::alloc::vec::Vec<u8>,
        #[prost(message, optional, tag = "4")]
        pub provider_meta: ::core::option::Option<super::DynamicValue>,
        #[prost(message, optional, tag = "5")]
        pub client_capabilities: ::core::option::Option<super::ClientCapabilities>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(message, optional, tag = "1")]
        pub new_state: ::core::option::Option<super::DynamicValue>,
        #[prost(message, repeated, tag = "2")]
        pub diagnostics: ::prost::alloc::vec::Vec<super::Diagnostic>,
        #[prost(bytes = "vec", tag = "3")]
        pub private: ::prost::alloc::vec::Vec<u8>,
        #[prost(message, optional, tag = "4")]
        pub deferred: ::core::option::Option<super::Deferred>,
    }
}

pub mod plan_resource_change {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Request {
        #[prost(string, tag = "1")]
        pub type_name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub prior_state: ::core::option::Option<super::DynamicValue>,
        #[prost(message, optional, tag = "3")]
        pub proposed_new_state: ::core::option::Option<super::DynamicValue>,
        #[prost(message, optional, tag = "4")]
        pub config: ::core::option::Option<super::DynamicValue>,
        #[prost(bytes = "vec", tag = "5")]
        pub prior_private: ::prost::alloc::vec::Vec<u8>,
        #[prost(message, optional, tag = "6")]
        pub provider_meta: ::core::option::Option<super::DynamicValue>,
        #[prost(message, optional, tag = "7")]
        pub client_capabilities: ::core::option::Option<super::ClientCapabilities>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(message, optional, tag = "1")]
        pub planned_state: ::core::option::Option<super::DynamicValue>,
        #[prost(message, repeated, tag = "2")]
        pub requires_replace: ::prost::alloc::vec::Vec<super::AttributePath>,
        #[prost(bytes = "vec", tag = "3")]
        pub planned_private: ::prost::alloc::vec::Vec<u8>,
        #[prost(message, repeated, tag = "4")]
        pub diagnostics: ::prost::alloc::vec::Vec<super::Diagnostic>,
        #[prost(bool, tag = "5")]
        pub legacy_type_system: bool,
        #[prost(message, optional, tag = "6")]
        pub deferred: ::core::option::Option<super::Deferred>,
    }
}

pub mod apply_resource_change {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Request {
        #[prost(string, tag = "1")]
        pub type_name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub prior_state: ::core::option::Option<super::DynamicValue>,
        #[prost(message, optional, tag = "3")]
        pub planned_state: ::core::option::Option<super::DynamicValue>,
        #[prost(message, optional, tag = "4")]
        pub config: ::core::option::Option<super::DynamicValue>,
        #[prost(bytes = "vec", tag = "5")]
        pub planned_private: ::prost::alloc::vec::Vec<u8>,
        #[prost(message, optional, tag = "6")]
        pub provider_meta: ::core::option::Option<super::DynamicValue>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(message, optional, tag = "1")]
        pub new_state: ::core::option::Option<super::DynamicValue>,
        #[prost(bytes = "vec", tag = "2")]
        pub private: ::prost::alloc::vec::Vec<u8>,
        #[prost(message, repeated, tag = "3")]
        pub diagnostics: ::prost::alloc::vec::Vec<super::Diagnostic>,
        #[prost(bool, tag = "4")]
        pub legacy_type_system: bool,
    }
}

pub mod import_resource_state {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Request {
        #[prost(string, tag = "1")]
        pub type_name: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub id: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "3")]
        pub client_capabilities: ::core::option::Option<super::ClientCapabilities>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ImportedResource {
        #[prost(string, tag = "1")]
        pub type_name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub state: ::core::option::Option<super::DynamicValue>,
        #[prost(bytes = "vec", tag = "3")]
        pub private: ::prost::alloc::vec::Vec<u8>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(message, repeated, tag = "1")]
        pub imported_resources: ::prost::alloc::vec::Vec<ImportedResource>,
        #[prost(message, repeated, tag = "2")]
        pub diagnostics: ::prost::alloc::vec::Vec<super::Diagnostic>,
        #[prost(message, optional, tag = "3")]
        pub deferred: ::core::option::Option<super::Deferred>,
    }
}

pub mod read_data_source {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Request {
        #[prost(string, tag = "1")]
        pub type_name: ::prost::alloc::string::String,
        #[prost(message, optional, tag = "2")]
        pub config: ::core::option::Option<super::DynamicValue>,
        #[prost(message, optional, tag = "3")]
        pub provider_meta: ::core::option::Option<super::DynamicValue>,
        #[prost(message, optional, tag = "4")]
        pub client_capabilities: ::core::option::Option<super::ClientCapabilities>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(message, optional, tag = "1")]
        pub state: ::core::option::Option<super::DynamicValue>,
        #[prost(message, repeated, tag = "2")]
        pub diagnostics: ::prost::alloc::vec::Vec<super::Diagnostic>,
        #[prost(message, optional, tag = "3")]
        pub deferred: ::core::option::Option<super::Deferred>,
    }
}

pub mod upgrade_resource_state {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Request {
        #[prost(string, tag = "1")]
        pub type_name: ::prost::alloc::string::String,
        #[prost(int64, tag = "2")]
        pub version: i64,
        #[prost(message, optional, tag = "3")]
        pub raw_state: ::core::option::Option<super::RawState>,
    }

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(message, optional, tag = "1")]
        pub upgraded_state: ::core::option::Option<super::DynamicValue>,
        #[prost(message, repeated, tag = "2")]
        pub diagnostics: ::prost::alloc::vec::Vec<super::Diagnostic>,
    }
}

pub mod stop_provider {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Request {}

    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Response {
        #[prost(string, tag = "1")]
        pub error: ::prost::alloc::string::String,
    }
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientCapabilities {
    #[prost(bool, tag = "1")]
    pub deferral_allowed: bool,
}

#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Deferred {
    #[prost(enumeration = "deferred::Reason", tag = "1")]
    pub reason: i32,
}

pub mod deferred {
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum Reason {
        Unknown = 0,
        ResourceConfigUnknown = 1,
        ProviderConfigUnknown = 2,
        AbsentPrereq = 3,
    }
}

// Type aliases used in mod.rs
pub type GetProviderSchema = get_provider_schema::Response;
pub type ConfigureProvider = configure_provider::Response;
pub type ValidateProviderConfig = validate_provider_config::Response;
pub type ValidateResourceConfig = validate_resource_config::Response;
pub type ReadResource = read_resource::Response;
pub type PlanResourceChange = plan_resource_change::Response;
pub type ApplyResourceChange = apply_resource_change::Response;
pub type ImportResourceState = import_resource_state::Response;
pub type ReadDataSource = read_data_source::Response;
pub type UpgradeResourceState = upgrade_resource_state::Response;
pub type StopProvider = stop_provider::Response;
