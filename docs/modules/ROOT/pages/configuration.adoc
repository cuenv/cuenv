= Configuration
:description: Comprehensive guide to cuenv configuration
:keywords: configuration, cue, environment, setup

Learn how to configure cuenv for your projects using CUE's powerful constraint-based configuration language.

== Configuration Files

cuenv uses CUE files for configuration, following a hierarchical structure that allows for composition and inheritance.

=== Default Configuration Files

cuenv looks for configuration in the following order:

1. `cuenv.cue` - Project-specific configuration
2. `env.cue` - Environment definitions  
3. `tasks.cue` - Task definitions
4. `.cuenv/` directory - Modular configurations

=== Basic Structure

[source,cue]
----
package config

// Project metadata
project: {
    name:    "my-project"
    version: "1.0.0"
}

// Environment variables
environment: {
    NODE_ENV: "development"
    PORT:     8080
    LOG_LEVEL: "info"
}

// Task definitions
tasks: {
    build: {
        description: "Build the project"
        command:     "npm run build"
        depends:     ["install"]
    }
    
    install: {
        description: "Install dependencies"
        command:     "npm install"
    }
}
----

== Environment Configuration

=== Basic Environments

Define environment variables with type constraints:

[source,cue]
----
environment: {
    // String variables
    NODE_ENV: "development" | "staging" | "production"
    SERVICE_NAME: string & =~"^[a-zA-Z][a-zA-Z0-9-]*$"
    
    // Numeric variables  
    PORT: int & >=1024 & <=65535
    WORKER_COUNT: int & >0 | *4  // Default to 4
    
    // Boolean variables
    DEBUG: bool | *false
    ENABLE_METRICS: bool | *true
}
----

=== Environment Composition

Compose environments from multiple sources:

[source,cue]
----
// Base environment
#BaseEnv: {
    LOG_LEVEL: "info" | "debug" | "warn" | "error"
    SERVICE_NAME: string
}

// Development environment
development: #BaseEnv & {
    LOG_LEVEL: "debug"
    DEBUG: true
    DATABASE_URL: "postgresql://localhost/myapp_dev"
}

// Production environment  
production: #BaseEnv & {
    LOG_LEVEL: "info"
    DEBUG: false
    DATABASE_URL: string  // Must be provided at runtime
}
----

=== Conditional Configuration

Use CUE's conditional logic for dynamic configuration:

[source,cue]
----
package config

// Configuration based on environment
let env = "development"  // or from external source

if env == "development" {
    database: {
        host: "localhost"
        port: 5432
    }
}

if env == "production" {
    database: {
        host: string  // Required from environment
        port: int & >0
        ssl:  true
    }
}
----

== Task Configuration

=== Basic Tasks

[source,cue]
----
tasks: {
    test: {
        description: "Run tests"
        command: "cargo test"
        environment: {
            RUST_LOG: "debug"
        }
    }
    
    lint: {
        description: "Run linter"
        command: "cargo clippy -- -D warnings"
    }
    
    build: {
        description: "Build project"
        command: "cargo build --release"
        depends: ["lint", "test"]
    }
}
----

=== Task Dependencies

Define complex dependency graphs:

[source,cue]
----
tasks: {
    // Parallel tasks (no dependencies)
    "lint:rust": {
        command: "cargo clippy"
    }
    
    "lint:js": {
        command: "eslint ."
    }
    
    // Sequential dependency
    test: {
        command: "cargo test"
        depends: ["lint:rust", "lint:js"]  // Waits for both
    }
    
    // Conditional dependencies
    deploy: {
        command: "kubectl apply -f k8s/"
        depends: ["build", "test"]
        if: environment.NODE_ENV == "production"
    }
}
----

=== Task Environment Inheritance

[source,cue]
----
// Shared task environment
#TaskEnv: {
    RUST_LOG: "info"
    PATH: "$PATH:/usr/local/bin"
}

tasks: {
    build: #TaskEnv & {
        command: "cargo build"
        environment: {
            CARGO_TARGET_DIR: "target"
        }
    }
    
    test: #TaskEnv & {
        command: "cargo test"
        environment: {
            RUST_LOG: "debug"  // Override shared value
        }
    }
}
----

== Schema Definitions

=== Custom Schemas

Define reusable configuration schemas:

[source,cue]
----
// Schema definitions
#DatabaseConfig: {
    host:     string
    port:     int & >0 & <65536
    database: string
    username: string
    password: string  // Should be loaded from secrets
    ssl:      bool | *true
}

#ServiceConfig: {
    name:        string & =~"^[a-zA-Z][a-zA-Z0-9-]*$"
    port:        int & >1024
    replicas:    int & >0 | *3
    environment: [string]: string | number | bool
    database:    #DatabaseConfig
}

// Apply schema to configuration
service: #ServiceConfig & {
    name: "api-server"
    port: 8080
    database: {
        host:     "postgres.local" 
        port:     5432
        database: "myapp"
        username: "app_user"
        password: "$DATABASE_PASSWORD"  // From secret
    }
}
----

=== Validation Rules

Add custom validation constraints:

[source,cue]
----
#Config: {
    // Version must follow semantic versioning
    version: string & =~"^[0-9]+\\.[0-9]+\\.[0-9]+$"
    
    // Port must be available (runtime check)
    port: int & >1024 & <65536
    
    // Environment must be valid
    env: "development" | "staging" | "production"
    
    // Features can only be enabled in certain environments
    if env == "production" {
        debug: false
        profiling: false
    }
}
----

== Secret Management

=== Secret References

Reference external secrets in configuration:

[source,cue]
----
environment: {
    // Direct secret reference
    DATABASE_PASSWORD: {
        secret: "database-password"
        key:    "password"
        provider: "1password"  // or "aws-ssm", "gcp-secret-manager"
    }
    
    // Inline secret with templating
    CONNECTION_STRING: "postgresql://user:${secrets.db.password}@localhost/myapp"
}

// Secret definitions
secrets: {
    db: {
        password: {
            provider: "1password"
            vault:    "Development"
            item:     "Database Credentials"
            field:    "password"
        }
    }
}
----

=== Secret Providers

Configure different secret providers:

[source,cue]
----
secretProviders: {
    "1password": {
        account: "my-team"
        serviceAccountToken: "$OP_SERVICE_ACCOUNT_TOKEN"
    }
    
    "aws-ssm": {
        region: "us-east-1"
        prefix: "/myapp/"
    }
    
    "gcp-secret-manager": {
        project: "my-project-123"
    }
}
----

== Advanced Features

=== Modular Configuration

Split configuration across multiple files:

.cuenv.cue
[source,cue]
----
package config

import (
    "github.com/myorg/myproject/environments"
    "github.com/myorg/myproject/tasks"
)

project: {
    name: "myproject"
    version: "1.0.0"
}

// Include other modules
environment: environments.development
tasks: tasks.common
----

.environments/development.cue
[source,cue]
----
package environments

development: {
    NODE_ENV: "development"
    DEBUG: true
    DATABASE_URL: "postgresql://localhost/myapp_dev"
}
----

=== Template Functions

Use CUE's built-in functions for dynamic values:

[source,cue]
----
import "strings"

config: {
    // String manipulation
    serviceName: strings.ToLower("My-Service-Name")  // "my-service-name"
    
    // Environment-based configuration
    logLevel: {
        if environment.DEBUG {
            "debug"
        }
        if !environment.DEBUG {
            "info"  
        }
    }
    
    // Computed values
    serverAddress: "http://localhost:\(environment.PORT)"
}
----

== Configuration Validation

=== Built-in Validation

cuenv automatically validates configuration against schemas:

[source,bash]
----
# Validate current configuration
cuenv validate

# Validate specific files
cuenv validate env.cue tasks.cue

# Validate with custom schema
cuenv validate --schema schema.cue config.cue
----

=== Custom Validators

Extend validation with custom rules:

[source,cue]
----
#Validators: {
    // Port availability check
    portAvailable: {
        field: "port"
        check: "network.portAvailable"
        message: "Port {value} is not available"
    }
    
    // Database connectivity
    databaseReachable: {
        field: "database.host" 
        check: "network.tcpConnect"
        message: "Cannot connect to database at {value}"
    }
}
----

== Best Practices

=== Organization

* Keep configuration files small and focused
* Use meaningful names for fields and values
* Group related configuration together
* Document complex constraints with comments

=== Security

* Never commit secrets to version control
* Use secret references instead of plain text values
* Validate secret access patterns
* Rotate secrets regularly

=== Maintainability

* Use schemas to enforce consistency
* Leverage CUE's composition features
* Keep environment differences minimal
* Test configuration changes

== See Also

* xref:environments.adoc[Typed Environments] - Environment management patterns
* xref:tasks.adoc[Task Orchestration] - Task definition and execution
* xref:secrets.adoc[Secret Management] - Secure secret handling
* xref:examples.adoc[Examples] - Common configuration patterns