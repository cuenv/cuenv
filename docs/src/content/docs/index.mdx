---
title: cuenv
description: Two commands. Type-safe environments. Secrets that never leak. Tasks that run in parallel.
template: splash
hero:
  title: |
    <span class="text-gradient">cuenv</span>
  tagline: Two commands. Type-safe environments. Secrets that never leak. Tasks that run in parallel.
  actions:
    - text: Quick Start
      link: /quick-start/
      icon: right-arrow
      variant: primary
    - text: View on GitHub
      link: https://github.com/cuenv/cuenv
      icon: external
      variant: minimal
---

import { Card, CardGrid } from '@astrojs/starlight/components';

## The Problem

You've been here before: secrets in `.env` files that get committed, "works on my machine" bugs, CI pipelines that can't run in parallel, and copy-paste task definitions with no validation.

**cuenv fixes this with two primitives.**

---

## Two Primitives

<CardGrid>
  <Card title="cuenv exec -- <command>" icon="rocket">
    Run any command with validated environment variables and secrets resolved at runtime. Never store credentials on disk.

    ```bash
    cuenv exec -- npm start
    cuenv exec -e production -- ./deploy.sh
    ```
  </Card>
  <Card title="cuenv task <name>" icon="list-format">
    Run named tasks with automatic dependency resolution, parallel execution, and content-aware caching.

    ```bash
    cuenv task build
    cuenv task -e staging deploy
    ```
  </Card>
</CardGrid>

---

## Why This Matters

<CardGrid>
  <Card title="Secrets Never Leak" icon="lock">
    Secrets are fetched at runtime from 1Password, AWS, GCP, Vaultâ€”never written to disk, never exported to your shell, redacted from logs.
  </Card>
  <Card title="Validate Before You Run" icon="approve-check-circle">
    CUE constraints catch `NODE_ENV: "prod"` typos before they become runtime failures. Type-safe configuration for your entire team.
  </Card>
  <Card title="Parallel by Default" icon="random">
    Object keys run in parallel. Arrays run sequentially. Dependencies are respected. Your CI gets faster automatically.
  </Card>
  <Card title="Works Everywhere" icon="laptop">
    Shell integration loads your environment when you `cd` into a project. Nix integration provisions tools automatically.
  </Card>
</CardGrid>

---

## See It In Action

```cue
package cuenv

import "github.com/cuenv/cuenv/schema"

schema.#Project & {
  name: "my-project"
}

env: {
    NODE_ENV: "development" | "staging" | "production"

    // Secrets resolved at runtime, never stored
    DB_PASSWORD: schema.#OnePasswordRef & {
        ref: "op://vault/database/password"
    }
}

tasks: {
    // These run in parallel
    test: {
        unit:        { command: "npm", args: ["run", "test:unit"] }
        integration: { command: "npm", args: ["run", "test:e2e"] }
        lint:        { command: "npm", args: ["run", "lint"] }
    }

    // This waits for test to complete
    build: {
        command:   "npm"
        args:      ["run", "build"]
        dependsOn: ["test"]
    }
}
```

---

## Status

<CardGrid>
  <Card title="Core Engine" icon="approve-check-circle">
    Complete. Fast CUE evaluation with Rust performance.
  </Card>
  <Card title="CLI + Tasks" icon="approve-check-circle">
    Stable. `exec`, `task`, and shell integration working.
  </Card>
  <Card title="Secrets + Dagger" icon="warning">
    Beta. Secret resolvers and Dagger backend available.
  </Card>
</CardGrid>

---

## Get Started

<CardGrid>
  <Card title="Quick Start" icon="right-arrow">
    [Install cuenv and run your first command](/quick-start/) in under 5 minutes.
  </Card>
  <Card title="GitHub" icon="github">
    [Star us on GitHub](https://github.com/cuenv/cuenv) and contribute to the project.
  </Card>
</CardGrid>
