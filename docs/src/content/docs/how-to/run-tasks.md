---
title: Tasks
description: Task orchestration and execution in cuenv
---

cuenv provides a powerful task runner that leverages CUE for defining tasks, their dependencies, and their inputs/outputs. This enables parallel execution, caching, and hermetic builds.

## Defining Tasks

Tasks are defined in the `tasks` block of your configuration using explicit type annotations.

### Task Types

cuenv supports three task types:

- **`#Task`** - Single executable command or script
- **`#TaskGroup`** - Parallel execution (all children run concurrently)
- **`#TaskSequence`** - Sequential execution (steps run in order)

```cue
package cuenv

import "github.com/cuenv/cuenv/schema"

tasks: {
    // A simple command task
    hello: schema.#Task & {
        command: "echo"
        args: ["Hello, World!"]
    }

    // Tasks with explicit types for dependencies
    lint: schema.#Task & {
        command: "cargo"
        args: ["clippy"]
    }

    test: schema.#Task & {
        command: "cargo"
        args: ["test"]
    }

    // A task with dependencies (uses CUE references, not strings!)
    build: schema.#Task & {
        description: "Build the application"
        command: "cargo"
        args: ["build", "--release"]

        // Dependencies use CUE references for compile-time validation
        dependsOn: [lint, test]

        // Inputs to track for caching (files/globs)
        inputs: [
            "src/**/*",
            "Cargo.toml",
            "Cargo.lock"
        ]

        // Outputs generated by this task
        outputs: ["target/release/myapp"]
    }

    // Parallel execution - all children run concurrently
    checks: schema.#TaskGroup & {
        type: "group"  // Required discriminator
        format: schema.#Task & { command: "cargo", args: ["fmt", "--check"] }
        clippy: schema.#Task & { command: "cargo", args: ["clippy"] }
        audit:  schema.#Task & { command: "cargo", args: ["audit"] }
    }

    // Sequential execution - steps run in order
    deploy: schema.#TaskSequence & [
        schema.#Task & { command: "build" },
        schema.#Task & { command: "docker", args: ["push"] },
        schema.#Task & { command: "kubectl", args: ["apply"] },
    ]
}
```

:::tip[CUE Reference Dependencies]
Notice that `dependsOn: [lint, test]` uses **CUE references** (no quotes), not strings. This provides compile-time validation - if you reference a task that doesn't exist, CUE will report an error before execution.
:::

## Running Tasks

Use the `cuenv task` command to run tasks:

```bash
# List available tasks
cuenv task

# Run a specific task
cuenv task build

# Run with rich TUI visualization (shows DAG and parallel task output)
cuenv task build --tui
```

### Rich TUI Mode

The `--tui` flag enables an interactive terminal UI that provides:

- **Visual DAG**: See the task dependency graph with real-time status updates
- **Parallel Output**: View output from up to 4 tasks simultaneously in split-screen panes
- **Live Status**: Color-coded task states (pending, running, completed, failed, cached)
- **Progress Tracking**: Overall execution time and task counts

```bash
cuenv task dev --tui
```

**Keyboard Controls:**

- `q` or `Esc`: Quit when execution is complete
- `Ctrl+C`: Force quit/abort execution

## Dependencies & Parallelism

cuenv analyzes the dependency graph defined by `dependsOn`. Tasks that do not depend on each other will be executed in parallel, maximizing resource usage.

In the example above:

1. `lint` and `test` start in parallel.
2. `build` waits for both `lint` and `test` to complete successfully.
3. If either fails, `build` is skipped.

## Caching

cuenv supports computation caching. By defining `inputs` and `outputs`, cuenv can determine if a task needs to be re-run.

- **Inputs**: Files or glob patterns that the task reads. If these haven't changed since the last successful run, the task might be skipped.
- **Outputs**: Files or directories created by the task.

_(Note: Full caching implementation is currently in development. Check the project status for updates.)_

## Task Parameters

Tasks can accept arguments from the command line using the `params` field. This enables reusable, parameterized tasks.

### Defining Parameters

```cue
import "github.com/cuenv/cuenv/schema"

tasks: {
    "import.video": schema.#Task & {
        description: "Import a video from YouTube"
        command: "yt-dlp"
        args: [
            "{{0}}",                    // First positional argument
            "--format", "{{quality}}",   // Named argument
            "-o", "{{output}}"
        ]

        params: {
            // Positional arguments (order matters)
            positional: [
                {
                    description: "YouTube video ID or URL"
                    required: true
                }
            ]

            // Named arguments (--flag style)
            quality: {
                description: "Video quality"
                default: "best"
                short: "q"              // Enables -q shorthand
            }
            output: {
                description: "Output filename"
                default: "%(title)s.%(ext)s"
                short: "o"
            }
        }
    }
}
```

### Running Parameterized Tasks

```bash
# View task help and available parameters
cuenv task import.video --help

# Run with positional argument
cuenv task import.video dQw4w9WgXcQ

# Run with named arguments
cuenv task import.video dQw4w9WgXcQ --quality 720p

# Use short flags
cuenv task import.video dQw4w9WgXcQ -q 720p -o "video.mp4"

# Named arguments with = syntax
cuenv task import.video dQw4w9WgXcQ --quality=1080p
```

### Parameter Types

Parameters support several options:

| Field         | Description                                           |
| ------------- | ----------------------------------------------------- |
| `description` | Help text shown in `--help` output                    |
| `required`    | If `true`, task fails when argument is missing        |
| `default`     | Default value when argument is not provided           |
| `short`       | Single-character shorthand (e.g., `"q"` enables `-q`) |
| `type`        | Type hint: `"string"` (default), `"bool"`, or `"int"` |

### Interpolation

Use `{{placeholder}}` syntax in `command` and `args`:

- `{{0}}`, `{{1}}`, etc. - Positional arguments by index
- `{{name}}` - Named arguments by their key

```cue
import "github.com/cuenv/cuenv/schema"

tasks: {
    greet: schema.#Task & {
        command: "echo"
        args: ["Hello, {{0}}! Your favorite color is {{color}}."]
        params: {
            positional: [{ description: "Name", required: true }]
            color: { default: "blue" }
        }
    }
}
```

```bash
cuenv task greet Alice --color green
# Output: Hello, Alice! Your favorite color is green.
```

## Environment Injection

Tasks inherit the environment variables defined in your `env` block. You can also define task-specific environment variables:

```cue
import "github.com/cuenv/cuenv/schema"

tasks: {
    test: schema.#Task & {
        command: "bun"
        args: ["test"]
        env: {
            // Override or add specific variables
            CI: "true"
            LOG_LEVEL: "debug"
        }
    }
}
```

## Hermeticity (Planned)

Future versions of cuenv will support hermetic execution, where tasks run in isolated environments (sandboxes) with only declared inputs available. This ensures reproducibility and prevents "it works on my machine" issues.
